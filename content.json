{"pages":[{"title":"正在整理中 。。。。。。","text":"","link":"/about/index.html"}],"posts":[{"title":"iOS逆向笔记","text":"逆向环境搭建iPhone越狱操作pp助手 爱思助手(一键越狱未成功) 刚开始使用unc0ver对几款iphone进行越狱安装后均显示不支持,所以改用checkra1n 先将官网放上https://checkra.in/ 刚开始用的官网下载的0.9.8.2刷机均中途报错 Exploit Failed (Error code: -31) 或 Timed out waiting for bootstrap upload(Likely caused by an incompatible tweak, to enable Safe Mode check the option on main screen) (Error code: -20) 后搜到这篇文章,看到有0.10.0版本的过段换最新的试试. https://mrmad.com.tw/checkra1n 最后贴上越狱成功下载地址 [v0.10.0 Beta](https://assets.checkra.in/test/checkra1n beta 0.10.0.dmg) mac远程登录iPhone通过ssh让mac远程登录iphone 1.手机端安装Cydia安装openssh工具 2.使用查看插件descrition中的描述 3.确保mac和iphone在同一局域网下,在mac的终端输入ssh 账户名@服务器主机地址 例如ssh root@10.1.1.168 (初始密码一般为alpine) 4.退出连接 exit 相关拓展: iOS下有2个常用账户:root/mobile root:最高权限账户,$HOME是/var/root mobile:普通权限账户,只能操作一些普通文件,不能操作系统级别的文件,$HOME是/var/mobile 修改登录密码 passwd 修改root密码 Passwd mobile 修改mobile用户密码 参考文章链接 Cycript通过cydia安装cycript可在iphone上调试运行中的app 常用指令 开启 cycript cycript -p 进程ID cycript -p 进程名称 取消输入: Ctrl + C 退出: Ctrl + D 清屏:Command + R 常用语法 UIApp 获取app对象 #内存地址 用内存地址获取对象 ObjectiveC.classes 已加载的所有OC类 *对象 查看对象的所有成员变量 view.recursiveDescription().toString() 递归打印view的所有子控件 choose(UITableViewCell) 筛选出某种类型的对象 mj工具类 ps命令手机安装adv-cmds插件 使用ps命令可以列出系统当前的进程 列出所有的进程 ps -A ps aux 搜索关键词 ps -A|grep 关键词 Reveal界面调试工具可以用其找到对应要操作视图类 Mach-O Class-dump对Mach-o文件进行静态分析,导出对应的头文件 导出指令 Class-dump -H Mach-O 文件路径 -o 头文件存放目录 -H表示要生成头文件 -o用于制定头文件的存放目录 头文件导出,可导出oc,swift过滤 http://stevenygard.com/projects/class-dump/ 参考 脱壳加壳是通过特殊算法,对可执行文件的编码进行改变(比如压缩/加密),以达到保护程序代码的目的. 脱壳就是将未加密的文件还原出来. 手机安装crackerXI插件,获取脱壳后文件,使用ifunbox将其导出. TWeak实战实战课参考此文章","link":"/2020/04/09/app%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/"},{"title":"Markdown常用语法","text":"第一章 块元素1.1标题标题有6个等级，用#号表示 1234567# 标题1## 标题2## 标题2### 标题2#### 标题4##### 标题5###### 标题6 1.2引用使用&gt;字符，表示引用 123&gt; This is a blockquote with two paragraphs. This is first paragraph.&gt; This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. This is a blockquote with two paragraphs. This is first paragraph.This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. 1.3列表12* red* blue red blue 121. red2. blue red blue 1.4任务列表用 [ ] 或者 [X] 未完成，完成）表示列表，通过点击复选框来更改状态（完成/未完成） 12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed a task list item list syntax required normal formatting, @mentions, #1234 refs incomplete completed 1.5代码块使用 ```&lt;语言&gt; 按回车键，将会对代码进行高亮 12345​```rubyrequire 'redcarpet'markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html​ 12345```rubyrequire 'redcarpet'markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html ###1.6数学 可以使用MathJax呈现LaTeX数学表达式 1234567$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\\\end{vmatrix}$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$ 1.7表格使用 | First Header | Second Header | 按回车键，将会创建2列的表格 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell 还可以使用 : 号，来设置文字对齐方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 ###1.8 脚注 1234使用 [^footnote] 创建脚注.You can create footnotes like this[^1].[^1]: Here is the *text* of the **footnote**.然后，可以把鼠标停留在脚注中，查看内容 You can create footnotes like this[^1].[^1]: Here is the text of the footnote. 1.10横线输入 *** 或者 — 后，按回车键 1.11目录输入 [toc] ，按回车键 [TOC] 第二章 Span元素2.1链接文字描述包含在 [] 内，链接地址包含在 () 内，() 要紧接着 [] 后面 12This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. This is an example inline link.This link has no title attribute. 2.1.1引用链接123[Bing][]And then define the link:[Bing]: http://bing.com/ BingAnd then define the link: 2.2图片123在链接格式前面添加 ! ，如下![在这里插入图片描述](http://pxebjkhug.bkt.clouddn.com/image-20190906161123468.png) 在链接格式前面添加 ! ，如下 ###2.3 强调 对应 HTML 的 标签 12*single asterisks*_single underscores_ single asterisks single underscores 如果像使用 * 号，在 * 号前使用 \\ 1\\*this text is surrounded by literal asterisks\\* *this text is surrounded by literal asterisks* 2.4加粗12**double asterisks**__double underscores__ double asterisksdouble underscores 2.5代码在文章中现实代码，用 ` 号表示 1Use the `printf()` function. Use the printf() function. 2.6删除线1~~Mistaken text.~~ Mistaken text. 2.7下划线1&lt;u&gt;Underline&lt;/u&gt; Underline ###2.8Emoji 表情 用两个 : 号包含单词，或者在 编辑 -&gt; 表情与符号 中选择 1:happy: :happy: 2.9高亮这个功能默认是关闭的，如果要打开这个功能（以 Mac 版本为例），选择 Typora -&gt; 偏好设置 -&gt; markdown 标签，勾选高亮复选框 1==highlight== ==highlight==","link":"/2019/09/10/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"title":"ES6学习笔记","text":"ES6:ECMAScript是JavaScript的标准，JS是ES的实现，主流实现只有JS，所以很多时候JS就等同于ECMA正式名称：ES2015，是ECMA标准的第六版 变量:var存在的问题: 12345678910111、重复声明： var a=12; var a=5；2、不能限制修改： var GIT_HOST='github.com' if(GIT_HOST='git')3、块级作用域： ES5的var作用域——函数级 ES6的let作用域——块级 let:变量,防止重复定义const:常量,防止重复定义 小总结： 变量： var:重复声明，不能限制修改，函数级 let:不能重复声明，变量,块级 const:不能重复声明,常量，块级解构赋值:json = {a:12,b:5}; let (a,b)=json; arr = [1,2,3]; let [a,b,c]= arr; 12345671、两边结构必须一样 let {a,b}=[1,2]2、右边必须是个正常数据结构 let {a,b}={1,2}3、赋值与解构同时完成 let {a,b}; {a,b}={a:1,b:2} 箭头函数:function(){ ..... } ()=&gt;{}简写： 1、如果有且仅有一个参数，（）可不写 2、如果有且仅有一个语句并且是return，{}也可以不写 修正this …参数展开 收集剩余参数 1234function show(a,b,...c){ console(a,b,c);}show(1,2,3,4); ​ 展开 1234567891011数组展开let arr1 = [1,2,3];let arr2 = [4,5,6];let arr = [...arr1,...arr2]json展开let json = {a:12,b:5,c:99};let json2 = { ...json, d:100}; Array扩展:map 映射，一一对应（n=&gt;n）reduce n=&gt;1filter 过滤（n=&gt;?）forEach 遍历 1234567891011121314151617181920212223242526let arr = [68,53,32,98,65];let strArr =arr.map(function (item){ return item&gt;=60?'及格':'不及格';})//求平均数let pj = arr.reduce(function (tmp,item,index){ if(index == arr.length-1){ return (temp + item)/arr.length; }else{ return temp + item; }});//取出偶数let arr3 = arr.filter(item=&gt;{ if(item%2==1){ return false; }else{ return true; }})arr.forEach((item,index)=&gt;{ }) 模板字符串:1234let arr=[12,56,87,95,64]; arr.forEach((item,index) =&gt; { alert(`第${index}个：${item}`); }); JSON:stringify:JSON-&gt;字符串Parse:json字符串-&gt;JSON 12JSON.stringify({a:12,b:5}); =&gt; '{&quot;a&quot;:12,&quot;b&quot;:5}'JSON.parse('{&quot;a&quot;:12,&quot;b&quot;:5}'); babel编译 (向后适配)本地使用: 1、安装node 2、安装babel npm i @babel/core @babel/cli @babel/preset-env npm i @babel/polyfill 3、添加脚本 &quot;build&quot;:&quot;babel src -d dest&quot; //从src输出到dest 4、添加.babelrc配置文件 { &quot;presets&quot;:{ &quot;@babel/preset-env&quot; } } 5、执行编译 npm run build 异步操作:异步操作：同时进行多个操作，用户体验，es6之前代码混乱同步操作：一次只能进行一个操作，用户体验不好，代码清晰 异步的同步写法: 1234567891011121314151617181920212223242526Promise 1、封装异步操作 let p = new Promise(function(resolve,rejext){ $.ajex({ url:'', success(arr){ resolve(arr); }, error(res){ reject(res); } }); }); p.then(function(data){ console.log('成功了'); },function(res){ console.log('失败了'); }); 2、promise.all{[ //并行调用p1,p2 p1, p2, ... ]}.then 3、promise.race 竞速调用 123456789 async/await 普通函数——一直执行，直到结束 async函数——能够\"暂停\"async function show(){ ....; let data = await $.ajax(); //等待请求完成后继续执行 ....; } 面向对象语言发展： 机器语言-&gt;汇编语言-&gt;低级语言（面向过程）-&gt;高级语言（面向对象）-&gt;模块系统-&gt;框架-&gt;系统接口（API） 封装 ES5面向对象（未标准化） 没有统一的写法 ES6面向对象（语法糖） 统一的写法继承： 1、省事 2、便于扩展 ES6新加： class 类声明 constructor 构造函数 extends 继承关键字 super 父类/超类 123456789101112131415161718192021222324class Person{ constructor(name,age){ this.name = name; this.age = age; } showName(){ console.log(this.name); }}let p = new Person();p.showName();class Worker extends Person{ constructor(name,age,job){ super(name,age); this.job = job; } showJob(){ console.log(this.job); }} 模块系统1、定义 12export let a= 12;export let b = 5; 2、使用 1、导出（export） //变量 export let a=1; //函数 export function show(){ …… } //类 export class Person{ ……. } //默认成员 export default …. ​ 2、导入​ import * as model from xxx 引入所有成员​ import model from xxx 引入default成员​ import {a,b as name} from xxx​ //只引入，不使用​ import ‘xxx’​ //异步引入​ let p=import(xxxx)​ 3、webpack编译 (因暂时浏览器不支持模块化,所以是需要wp编译) ES6+幂操作 Array.includes() async/await reset/spread 异步迭代 正则表达式增强","link":"/2020/04/22/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"小程序flex布局","text":"尺寸单位rpx,规定屏幕宽为750rpx flex布局flex布局是小程序经常使用布局方式 开启方式: display:flex; (black-level形式存在) 或 display:inline-flex; (inline-level形式存在) 开启flex布局的元素叫flex container,其中直系子元素叫做flex items 属性flex-derection决定了main axis的方向 属性值: row | row-reverse | column | column-reverse justify-content决定了flex items在main axis上的对其方式 flex-start(默认值):与main start对齐 flex-end:与main-end对齐 center:居中对齐 space-between:items之间的距离相等,与main-start,main-end两端对齐 Space-evenly:items之间的距离相等,items与main-start,main-end之间的距离等于items之间的距离. Space-around:items之间的距离相等,与main-start,main-end之间的距离等于items之间的距离的一半 Align-items决定了在cross axis上的对其方式 stretcha(默认值):当flex-items在cross axis方向的size为auto时,会自动拉伸至填充flex container Flex-start:与cross start对齐 Flex-end:与cross end对齐 center: 居中对齐 Baseline:与基准下对齐 Flex-wrap决定了flex container是单行还是多行 nowrap(默认):单行 wrap:多行 Wrap-reverse:多行(对比wrap,cross start与cross end相反) flex-flow是flex-derection || flex-wrap的简写 比如flex-flow:column wrap等价于 Flex-derection:colunm Flex-warp:warp Align-content决定了多行flex items在cross axis上的对齐方式,用法与justify-content类似 stretch(默认值):与align-items的stretch类似 Flex-start:与cross start对齐 Flex-end:与cross end对齐 Center:居中对齐 Space-between:items之间的距离相等,与cross-start,cross-end两端对齐 Space-around:items之间的距离相等,与cross-start,cross-end之间的距离等于items之间的距离的一半 Space-evenly:items之间的距离相等,items与cross-start,cross-end之间的距离等于items之间的距离. order决定了flex items的排布顺序 可以设置任意整数(正负数/0),值越小就越排在前面 默认值为0 Align-self flex items可以通过align-self覆盖flex contaner设置的align-items auto(默认值):遵从flex container的align-items设置 Stretch/flex-start/flex-end/center/baseline Flex-grow决定了flex items如何扩展多余空间 可以设置任意非负数字(正数/0),默认值是0 当flex container在main axis方向上有剩余size时,flex-grow属性才有效 flex-shrink决定了flex items如何收缩 可以设置任意非负数字(正数/0),默认值是1 当flex itemx在main axis方向上超过了flex container的size,flex-shrink属性才有效 flex-basis用来设置flex items在main axis方向上的bese size auto(默认值): content:取决于内容本身的size 决定了flex items最终base size的因素,游戏那几从高到低 Max-width\\max-height\\min-width\\min-height Flex-basis Width\\height 内容本身的size flex是flex-grow flex-grow flex-shrink? || flex-basis的简写 默认值 0 1 auto none:0 0 auto","link":"/2020/04/22/%E5%B0%8F%E7%A8%8B%E5%BA%8Fflex%E5%B8%83%E5%B1%80/"},{"title":"微信小程序学习笔记","text":"一、小程序代码组成1.1 JSON配置123456789101112{ \"pages\":[ \"pages/index/index\", \"pages/logs/logs\" ], \"window\":{ \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" }} 注意点： 1.json的key必须包裹在一个双引号中； 2.json的值支持以下数据类型： ​ 数字：包含浮点数和整数 ​ 字符串：需要包裹在双引号中 ​ Bool值，true或者false ​ 数组：需要包裹在方括号中[] ​ 对象：需要包裹在大括号中{} ​ Null 3.json文件无法使用注释 1.2 WXML模板 1.数据绑定 12&lt;!--pages/wxml/index.wxml--&gt;&lt;text&gt;当前时间：{{time}}&lt;/text&gt; ​ 2.属性值的绑定(属性值必须被包裹在双引号中) 1&lt;text data-test=\"{{test}}\"&gt; hello world&lt;/text&gt; 语法内可进行简单的逻辑运算 123456三元运算&lt;!-- 根据 a 的值是否等于 10 在页面输出不同的内容 --&gt;&lt;text&gt;{{ a === 10? \"变量 a 等于10\": \"变量 a 不等于10\"}}&lt;/text&gt;算数运算&lt;view&gt; {{a + b}} + {{c}} + d &lt;/view&gt; 4.条件逻辑 12345&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;&lt;view wx:if=&quot;{{length &gt; 5}}&quot;&gt; 1 &lt;/view&gt;&lt;view wx:elif=&quot;{{length &gt; 2}}&quot;&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 5.列表渲染 12345678&lt;view wx:for=\"{{array}}\"&gt; {{index}}: {{item.message}}&lt;/view&gt;&lt;!-- 使用 wx:for-item 指定数组当前元素的变量名，使用 wx:for-index 指定数组当前下标的变量名：--&gt;&lt;view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\"&gt; {{idx}}: {{itemName.message}}&lt;/view&gt; 6.wx:key的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 123456&lt;switch wx:for=&quot;{{objectArray}}&quot; wx:key=&quot;unique&quot; &gt; {{item.id}} &lt;/switch&gt;&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;&lt;switch wx:for=&quot;{{numberArray}}&quot; wx:key=&quot;*this&quot; &gt; {{item}} &lt;/switch&gt;&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add Number to the front &lt;/button&gt; 7.模板 12345678910111213141516&lt;!--item: { index: 0, msg: 'this is a template', time: '2016-06-18'}--&gt;&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt; &lt;text&gt; Time: {{time}} &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt; 8.引用 WXML 提供两种文件引用方式import和include。 import 可以在该文件中使用目标文件定义的 template，只会 import 目标文件中定义的 template，而不会 import 目标文件中 import 的 template，简言之就是 import 不具有递归的特性 include 可以将目标文件中除了 外的整个代码引入，相当于是拷贝到 include 位置 1.3 WXSS 样式 1.在WXSS中，引入了rpx（responsive pixel）尺寸单位,标准为750*1334rpx,标准和iphone6一样 2.引用 引用另一个样式文件：@import './test_0.wxss' 3.内联样式 1&lt;view style=&quot;color: red; font-size: 48rpx&quot;&gt;&lt;/view&gt; 4选择器 类型 选择器 样例 样例描述 类选择器 .class .intro 选择所有拥有 class=”intro” 的组件 id选择器 #id #firstname 选择拥有 id=”firstname” 的组件 元素选择器 element view checkbox 选择所有文档的 view 组件和所有的 checkbox 组 伪元素选择器 ::after view::after 在 view 组件后边插入内容 伪元素选择器 ::before view::before 在 view 组件前边插入内容 1.4JavaScript 脚本生命周期函数 参数属性 类型 描述 onLoad Function 生命周期函数–监听页面加载，触发时机早于onShow和onReady onReady Function 生命周期函数–监听页面初次渲染完成 onShow Function 生命周期函数–监听页面显示，触发事件早于onReady onHide Function 生命周期函数–监听页面隐藏 onUnload Function 生命周期函数–监听页面卸载 onPullDownRefresh Function 页面相关事件处理函数–监听用户下拉动作 onReachBottom Function 页面上拉触底事件的处理函数 onShareAppMessage Function 用户点击右上角转发 二、小程序界面2.1组件一个小程序页面可以分解成多个部分组成，组件就是小程序页面的基本组成单元。为了让开发者可以快速进行开发，小程序的宿主环境提供了一系列基础组件。 组件共有属性 属性名 类型 描述 其他说明 id String 组件的唯一标示 保持整个页面唯一 class String 组件的样式类 在对应的WXSS中定义的样式类 style String 组件的内联样式 可以通过数据绑定进行动态设置的内联样式 hidden Boolean 组件是否显示 所有组件默认显示 data-* Any 自定义属性 组件上触发的事件时，会发送给事件处理函数 bind / catch EventHandler 事件 绑定、捕获事件 微信官方组件https://developers.weixin.qq.com/miniprogram/dev/component/ 三方组件：https://youzan.github.io/vant-weapp/#/intro 2.2常见事件 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发 2.3page生命周期函数 三、API宿主环境提供了丰富的API，可以很方便调起微信提供的能力. 3.1路由跳转​ wx.switchTab(Object object) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 ​ wx.navigateTo(Object object)保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 3.2网络请求12345678910111213wx.request({ url: 'test.php', //仅为示例，并非真实的接口地址 data: { x: '', y: '' }, header: { 'content-type': 'application/json' // 默认值 }, success (res) { console.log(res.data) }}) 属性 类型 默认值 必填 说明 url string 是 开发者服务器接口地址 data string/object/ArrayBuffer 否 请求的参数 header Object 否 设置请求的 header，header 中不能设置 Referer。 content-type 默认为 application/json timeout number 否 超时时间，单位为毫秒 method string GET 否 HTTP 请求方法 dataType string json 否 返回的数据格式 responseType string text 否 响应的数据类型 enableCache boolean false 否 开启 cache success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 常用object.method 的合法值 值 说明 GET HTTP 请求 GET HEAD HTTP 请求 HEAD POST HTTP 请求 POST PUT HTTP 请求 PUT 3.3 数据缓存wx.setStorage(Object object) 将数据存储在本地缓存中指定的 key 中，所有数据存储上限为 10MB。 1234567891011wx.setStorage({ key:&quot;key&quot;, data:&quot;value&quot;})wx.getStorage({ key: 'key', success (res) { console.log(res.data) }}) wx.getStorage(Object object) 从本地缓存中异步获取指定 key 的内容 3.4 其他 更多api可以查看官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/ 四、云开发","link":"/2020/05/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"栈","text":"","link":"/2019/09/11/%E6%A0%88/"},{"title":"树","text":"","link":"/2019/09/16/%E6%A0%91/"},{"title":"线性表","text":"","link":"/2019/09/11/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"title":"队列","text":"","link":"/2019/09/11/%E9%98%9F%E5%88%97/"},{"title":"hexo博客搭建教程","text":"###简介 Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。 ###安装 因自己使用的mac电脑，这里以mac安装发布为例，windows大体差不多。 1.1电脑本地创建一个文件夹，例如我这里的blog。 1.2 打开电脑终端执行以下命令： 12$npm install -g hexo-cli$ hexo init 如果npm指令出现此报错zsh: command not found: node,需安装nodejs环境,下载链接 1.3 安装完成后，指定文件夹的目录如下 ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds是存放模板的文件夹，当新建文章时，Hexo会根据scaffold来建立文件；source是资源文件夹，用于存放用户资源，themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。 1.4生成静态博客，在终端执行命令： 1hexo s Hexo将source文件夹中的Markdown 和 HTML 文件会被解析并放到public文件夹中，public文件夹用于存放静态博客文件，相当于网站根目录。至此博客雏形基本完成，在浏览器中访问http://localhost:4000/，如图所示： 2.1主题更换 前往主题页，选择喜欢的主题： 2.2 挑选喜欢的主题后，将主题clone到blog的themes文件夹下 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 2.3 修改_config.yml中对应的主题字段为你选择的主题名 到此主题更换成功，可以本地hexo s本地看看是否替换成功。 3.1发布到github 可以参看这篇文章：怎么把Hexo的博客托管到Git上 4.常用hexo命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 指令缩写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令 12hexo s -g #生成并本地预览hexo d -g #生成并上传 5.Hexo博客多端同步解决办法","link":"/2019/09/06/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"title":"串","text":"","link":"/2019/09/11/%E4%B8%B2/"},{"title":"AFNetworking笔记","text":"","link":"/2020/05/14/AFNetworking%E7%AC%94%E8%AE%B0/"},{"title":"React学习笔记","text":"DAY1React生态圈jsx:拓展了js自身的语法,是react的基础 Flux:react的数据流组件 Redux:比flux更加简单、易用 React-Native:用react编写原生移动应用 React-server:服务端渲染react组件 jsx jsx是一门独立的语言,希望能改进js的很多问题,但是es6出现后,包含了jsx的大部分特性,所以很少独立使用 babel可以编译jsx react是基于jsx语法 提供模板式创建元素的方法 123456//普通元素创建let oDiv = document.createElement('div');odiv.title = 'aaa';oDiv.innerHTML = 'BBB';//jsx方式let oDiv = &lt;div title=\"aaa\"&gt;BBB&lt;/div&gt; 注意:jsx并不会真正创建dom元素,jsx只是解析模板语法,创建虚拟DOM节点,需经由ReactDOM渲染才会成为真正的DOM元素. 关于虚拟DOM 直接操作dom元素非常缓慢,所以很多框架(vue,react)都具备虚拟dom特性,我们直接操作的是虚拟dom,而非真正节点,react会在何时的实际批量更新dom节点(一般是主进程空闲时),从而提高性能. 能否单独使用jsx? 不能,react强依赖jsx用于解析jsx语法,但是jsx也强依赖react用于解析模板语法 第一个react程序 12345678910111213//引入js文件 &lt;script src=&quot;js/browser.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/react-dom.js&quot;&gt;&lt;/script&gt; //容器 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; //react渲染,经过babel编译才能执行 &lt;script type=&quot;text/babel&quot;&gt; let root = document.getElementById('root'); ReactDOM.render(&lt;div&gt;aaa&lt;/div&gt;,root); &lt;/script&gt; 特殊属性 react中类”html代码”,其实不是真正的html,而是jsx语法,绝大部分标签与html一样,但是有两个属性需要修改 class:className for:htmlFor 单标签 react中单标签必须闭合(html标签和自定义组件都是) ; 错误 ; 正确 react组件组件 123456789101112131415161718 //组件定义 class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ let a = 12; let name = 'qpc'; let age = 18; return &lt;div&gt; &lt;span style={{color:'red'}}&gt;你好&lt;/span&gt; 姓名:{name} 年龄:{age}&lt;/div&gt;; } }//组件渲染 let root = document.getElementById('root'); ReactDOM.render(&lt;Cmp1 txt=&quot;qpc&quot;&gt;&lt;/Cmp1&gt;,root); 注意: 组件必须继承React.Component 组件必须有constructor()且super父级,否则状态等功能无法使用 组件必须有render()方法 组件类名必须首字母大写 组件使用时,单双标签都可以 组件中的html必须规范(双标签闭合,单标签结尾加/) 模板输出 输出变量、属性、方法、任何东西都可以 123456789101112131415161718192021222324252627class Cmp1 extends React.Component{ constructor(...args){ super(...args); this.age = 18; } fn(){ return 55; } render(){ let name = 'qpc'; let age = 18; const a = 66; return &lt;div&gt; &lt;span style={{color:'red'}}&gt;你好&lt;/span&gt; //输出变量 姓名:{name} //输出属性 年龄:{this.age} {this.fn()}; //输出到属性 &lt;div title={a}&gt;div2&lt;/div&gt; &lt;/div&gt;; } } 组件传参 用props接受参数 1234567891011class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ return &lt;div&gt; {this.props.a},{typeof(this.props.a)} &lt;/div&gt; } } 组件输出 123456789101112131415161718192021222324 class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ let spana = &lt;span&gt;aaa&lt;/span&gt; return &lt;div&gt; {spana} &lt;/div&gt; } }//输出一组元素 render(){ let arr = [ &lt;span key={0}&gt;aaa&lt;/span&gt;, &lt;span key={1}&gt;bbb&lt;/span&gt;, &lt;span key={2}&gt;ccc&lt;/span&gt; ]; return &lt;div&gt; {arr} &lt;/div&gt; } 关于key key非常重要，它关联虚拟dom和真实dom，从而在虚拟dom修改时对实际dom元素做最小化额修改以此提高性能，普通元素其实也有key，由react自己生成 注意：尽量不要用index作为key,因为index是会变化的（比如删掉一个元素，后续元素的index会变化） key的选择标准： 唯一：否则reactdom无法重用 不变：否则dom元素混乱 组件循环 12345678render(){ let arr = [1，2，3]; return &lt;div&gt; {arr.map((item,index) =&gt;( &lt;span key={index}&gt;{item}&lt;/span&gt; ))} &lt;/div&gt;} 组件嵌套 1234567891011121314151617181920212223242526272829303132333435363738class item extends React.Component{ constructor(...args){ super(...args); } render(){ return ( &lt;li&gt; {this.props.data} &lt;/li&gt; ) } }class list extends React.Component{ constructor(...args){ super(...args); } render(){ let arr = [1,2,3]; return ( &lt;ul&gt; {arr.map((n,index)=&gt;&lt;item key={index} data={n}&gt;&lt;/item&gt;)} &lt;/ul&gt; ) } }//输出一组元素 render(){ let arr = [ &lt;span key={0}&gt;aaa&lt;/span&gt;, &lt;span key={1}&gt;bbb&lt;/span&gt;, &lt;span key={2}&gt;ccc&lt;/span&gt; ]; return &lt;div&gt; {arr} &lt;/div&gt; } 组件状态 状态 属性是只读的，状态是可变的 状态的改变，组件会重新渲染 1234567891011121314151617181920class Cmp1 extends React.Component{ constructor(...args){ super(...args); //初始化状态 this.state={a:0}; } add(){ this.setState({ a:this.state.a+1 }); } render(){ return &lt;div&gt; &lt;input type=\"button\" value=\"加1\" onClick={thi.add.bind(this)}&gt;&lt;/input&gt; {this.state.a} &lt;/div&gt; } } 注意： 状态的初始化只能在constructor中完成 必须通过setState修改状态，否则也不能重新渲染——setState调用了render props变化引起重新渲染 强制渲染(forceUpdate) 组件生命周期 componentDidMount组件已经挂载 shouldComponentUpdate:即将开始更新组件，可以阻值更新发生 componentDidUpdate组件已更新 组件引用 ref：需用引用的组件 refs:父级中引用所有ref组件 实例：求和 12345678910111213141516171819202122class Cmp1 extends React.Component{ constructor(...args){ super(...args); //初始化状态 this.state={sum:0}; } fn(){ this.setState({ sum:parseInt(this.refs.num1.value)+parseInt(this.refs.num2.value) }); } render(){ return &lt;div&gt; &lt;input type=\"text\" ref=\"num1\"/&gt; &lt;input type=\"text\" ref=\"num2\"/&gt; &lt;input type=\"button\" value=\"求和\" onClick={thi.fn.bind(this)}/&gt; {this.state.sum} &lt;/div&gt; } } 和vue有所不同，react中的ref不能重复，如果重复，后面的会覆盖掉前面的 组件通信 redux","link":"/2020/05/13/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"iOS线上crash日志分析","text":"因为线上统计用的百度sdk,现在记录下针对百度错误日志的手动分析方法,其官网文档有自动和手动分析两种方法. 这里记录一下自己手动定位crash报错方法的流程: 百度移动统计iOS SDK获取的crash日志不是完整的系统生成日志，其内容主要包括异常类型、原因、Backtrace调用等. SDK V3.5及以上的SDK，日志格式会在头部新增相关信息，如下: 1234UUID: 538572BD-D973-3D55-A475-4579BA0BECBFNAME: BaiduMobStatSampleARCH: x86_64ADDR: 0x100000000 bug分析命令：**xcrun atos –arch arm64 -o +包路径 -l 基地址 + 偏移地址** 1、获取包路径 （1）XCode-&gt;Window-&gt;Organizer （2）找到对应的安装包并双击点击show in Finder （3）双击.xcarchive文件显示包内容 （4）双击.app.dsYM文件显示报内容 （5）按照如下路径找到APP名字的文件 （6）打开终端输入(xcrun atos -arch arm64 -o )然后（将appname文件拖到此处，如下图） （7）输入（-l）+ (崩溃日志中的ADDR如下图) + （APPname后面对应的一串字符如下图的蓝圈内的地址）输入完成之后回车就可以了 8、最终结果如下，会解析出类名，和报错的行数","link":"/2020/07/27/iOS%E7%BA%BF%E4%B8%8A%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%88%86%E6%9E%90/"},{"title":"读&lt;&lt;图解物联网读书&gt;&gt;","text":"感觉物联网现在越来越热门,智能家居/工业物联网应用越来越多,于是想全面的连接物联网基本知识结构,所以看了该书.感觉不错,本书从硬件到软件到物联云,系统了讲解了开发物联网应用需要的知识. 全书看下来,感觉当前还是处于物联网初期,感觉物联网应用的比较多的还是工业,智能家居也有不少的用户开始接受了,但是比较零散,很多没有形成系统,很多设备只是简单了添加联网模块,未给硬件添加智能化和自动化,不过自动驾驶应该是一项技术突破,设计到n多传感器和自动化驾驶.","link":"/2020/07/01/%E8%AF%BB-%E5%9B%BE%E8%A7%A3%E7%89%A9%E8%81%94%E7%BD%91%E8%AF%BB%E4%B9%A6/"},{"title":"iOS音视频开发","text":"","link":"/2020/05/28/iOS%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"hexo博客","slug":"hexo博客","link":"/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"串","slug":"串","link":"/tags/%E4%B8%B2/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"AFNetworking","slug":"AFNetworking","link":"/tags/AFNetworking/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"iOS逆向","slug":"iOS逆向","link":"/tags/iOS%E9%80%86%E5%90%91/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"crash","slug":"crash","link":"/tags/crash/"},{"name":"物联网","slug":"物联网","link":"/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"物联网","slug":"物联网","link":"/categories/%E7%89%A9%E8%81%94%E7%BD%91/"}]}