{"pages":[{"title":"正在整理中 。。。。。。","text":"","link":"/about/index.html"}],"posts":[{"title":"AFNetworking笔记","text":"AFNetworking 一 代码结构 主要有5大功能模块: 网络通信模块（最核心）（AFURLSessionManager、AFHTTPSessionManager） 网络状态监听模块（Reachability） 网络通信安全策略模块（Security） 网络通信信息序列化/反序列化模块（Serialization） 对于iOS UIkit库的拓展（UIKit） 二 AFHTTPSessionManager发起网络请求首先来看初始化AFHTTPSessionManager对象的过程，其中需要注意的是[AFHTTPSessionManager manager]方法并不是单例，最终调用的是下面初始化方法,工厂设计模式。 在AFHTTPSessionManager初始化中主要做了 1、调用父类初始化方法; 2、给URL加’’; 3、给requestSerializer、responseSerializer设置默认值 给url加’/‘的目的应该是1、防重发 2、方便在url后面直接拼接参数。 12345678910111213141516- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration{ self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) { url = [url URLByAppendingPathComponent:@&quot;&quot;]; } self.baseURL = url; self.requestSerializer = [AFHTTPRequestSerializer serializer]; self.responseSerializer = [AFJSONResponseSerializer serializer]; return self;} 下面来看AFURLSessionManager初始化方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super init]; if (!self) { return nil; } if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; self.responseSerializer = [AFJSONResponseSerializer serializer]; self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self;} 主要步骤有： sessionConfiguration 属性持有 configuration ，若传入configuration为空，设置默认defaultSessionConfiguration。包含缓存策略，ID，超时时间 … 初始化代理方法执行的队列operationQueue，并设置 maxConcurrentOperationCount 值为1。即串行执行 responseSerializer 解析方式， securityPolicy 使用defaultPolicy初始化，https证书校验对象，用来校验服务端安全信任链接 reachabilityManager 网络状态监听。 mutableTaskDelegatesKeyedByTaskIdentifier 类型是NSMutableDictionary，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象 lock ，NSLock类型锁创建，为了保证线程安全 session对象创建，3.0版本是直接创建。4.0版本是懒加载形式创建，并使用@synchronized互斥锁保证只创建一次 session 调用getTasksWithCompletionHandler方法获取 之前的task，创建AFURLSessionManagerTaskDelegate。绑定task，并加入mutableTaskDelegatesKeyedByTaskIdentifier字典中 manager的研究先到这里，里面各种配置的具体实现，暂时先不往深处介绍了，下面来看下request的实现方法 request方法解析 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(nullable id)parameters headers:(nullable NSDictionary &lt;NSString *, NSString *&gt; *)headers uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure{ NSError *serializationError = nil; //URLWithString:(NSString *)URLString relativeToURL: 拼接字符串 //absoluteString完整的url字符串 NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; for (NSString *headerField in headers.keyEnumerator) { [request setValue:headers[headerField] forHTTPHeaderField:headerField]; } if (serializationError) { if (failure) { dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); } return nil; } __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; return dataTask;} 1、这个过程主要是使用requestSerializer 调用requestWithMethod 或者 multipartFormRequestWithMethod 获取 NSMutableURLRequest 类型的 request 对象。 使用指定的HTTP method和URLString来构建一个NSMutableURLRequest对象实例，如果method是GET、HEAD、DELETE，那parameter将会被用来构建一个基于url编码的查询字符串（query url），并且这个字符串会直接加到request的url后面。对于其他的Method，比如POST/PUT，它们会根据parameterEncoding属性进行编码，而后加到request的http body中。 1234- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters error:(NSError *__autoreleasing *)error 在上面这个方法里设置了request的 请求方法，url，遍历mutableObservedChangedKeyPaths中设置的属性并给Request赋值。 调用[mutableRequest setValue:value forHTTPHeaderField:field]方法设置请求头相关信息。 非HTTPMethodsEncodingParametersInURI的请求先判断request的Content-Type是否设置了，如果没有，就默认设置为application/x-www-form-urlencoded。 在方法 multipartFormRequestWithMethod 中比 requestWithMethod 多了个参数为formData 的 block 对象参数。在方法体里面对formData 进行拼接。然后通过block传出去。此处设计与Masonry框架中block使用方式相同，可以放一块研究一下。 2、调用 dataTaskWithRequest 方法，使用上面的 request 生成 task 对象。 12NSURLSessionDataTask *dataTask = [self.session dataTaskWithRequest:request];[self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; addDelegateForDataTask 方法将初始化一个 AFURLSessionManagerTaskDelegate 对象，delegate 弱引用又持有了 manager, 打破闭环。在delegate中有 进度，回调，存储数据的mutableDate等属性。 在addDelegateForDataTask 中调用 setDelegate：forTask 将task 和 delegate 绑定到一起。 在setDelegate:forTask 方法中 1、将delegate存入字典，以taskid作为key，说明每个task都有各自的代理； 2、设置两个NSProgress的变量 - uploadProgress和downloadProgress，给session task添加了两个KVO事件 设置这两个NSProgress对应的cancel、pause和resume这三个状态，正好对应session task的cancel、suspend和resume三个状态 当NSURLSessionTask调用resume函数时，会postNotificationName:AFNSURLSessionTaskDidResumeNotification，从而执行taskDidResume:方法 在 taskDidResume: 方法中会判断task是否是当前manager管理的，是的话会发送通知AFNetworkingTaskDidResumeNotification 3、task调用resume 执行 resume 方法被 使用 method_exchangeImplementations交换为 af_resume方法。内部发送了AFNSURLSessionTaskDidResumeNotification 通知。 参考文章: https://juejin.cn/user/3729141714925687/posts","link":"/2020/05/14/AFNetworking%E7%AC%94%E8%AE%B0/"},{"title":"ES6学习笔记","text":"ES6:ECMAScript是JavaScript的标准，JS是ES的实现，主流实现只有JS，所以很多时候JS就等同于ECMA正式名称：ES2015，是ECMA标准的第六版 变量:var存在的问题: 12345678910111、重复声明： var a=12; var a=5；2、不能限制修改： var GIT_HOST='github.com' if(GIT_HOST='git')3、块级作用域： ES5的var作用域——函数级 ES6的let作用域——块级 let:变量,防止重复定义const:常量,防止重复定义 小总结： 变量： var:重复声明，不能限制修改，函数级 let:不能重复声明，变量,块级 const:不能重复声明,常量，块级解构赋值:json = {a:12,b:5}; let (a,b)=json; arr = [1,2,3]; let [a,b,c]= arr; 12345671、两边结构必须一样 let {a,b}=[1,2]2、右边必须是个正常数据结构 let {a,b}={1,2}3、赋值与解构同时完成 let {a,b}; {a,b}={a:1,b:2} SymbolES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最多的用法是用来定义对象的唯一属性名 Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象 作为对象属性名时不能用.运算符，要用方括号。因为.运算符后面是字符串，所以取到的是字符串 sy 属性 Symbol 值作为属性名时,可以在类的外部访问。但是不会出现在 for…in 、 for…of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 获取 12345let syObject = {};syObject[sy] = &quot;kk&quot;; syObject[sy]; // &quot;kk&quot;syObject.sy; // undefined mapmap和object的区别 map是干净的，只含有显示插入的键，而Object上会有原型上的属性以及方法，es5之后可以说使用Object.create(null)来创建一个干净的对象(vuex源码中大量使用) map的键可以是任意的数据类型，包括基本的数据类型，对象以及函数，而object只允许使用symbol以及string或数值 map中的key是有序的，迭代的时候以其插入的顺序返回键值，而object的键是无序的map长度可以通过size方法来获取，而object需要手动计算(Object.keys(obj).length) map是可迭代的，object需要通过获取键来迭代 Map在频繁增删键值对的场景下表现更好，在频繁添加和删除键值对的场景下未作出优化。 setSet 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用 123456let mySet = new Set();mySet.add(1); // Set(1) {1}mySet.add(5); // Set(2) {1, 5}var mySet1 = new Set([1, 2, 3, 4, 4]);[...mySet1]; // [1, 2, 3, 4] stringES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法 includes()：返回布尔值，判断是否找到参数字符串。 startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部 repeat()：返回新的字符串，表示将字符串重复指定次数返回 padStart：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。 padEnd：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。 1console.log(&quot;h&quot;.padStart(5,&quot;o&quot;)); // &quot;ooooh&quot; 模板字符串: 1234let arr=[12,56,87,95,64];arr.forEach((item,index) =&gt; { alert(`第${index}个：${item}`);}); JSON: stringify:JSON-&gt;字符串Parse:json字符串-&gt;JSON 12JSON.stringify({a:12,b:5}); =&gt; '{&quot;a&quot;:12,&quot;b&quot;:5}'JSON.parse('{&quot;a&quot;:12,&quot;b&quot;:5}'); Array扩展:map 映射，一一对应（n=&gt;n）reduce n=&gt;1filter 过滤（n=&gt;?）forEach 遍历find 查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素 1234567891011121314151617181920212223242526let arr = [68,53,32,98,65];let strArr =arr.map(function (item){ return item&gt;=60?'及格':'不及格';})//求平均数let pj = arr.reduce(function (tmp,item,index){ if(index == arr.length-1){ return (temp + item)/arr.length; }else{ return temp + item; }});//取出偶数let arr3 = arr.filter(item=&gt;{ if(item%2==1){ return false; }else{ return true; }})arr.forEach((item,index)=&gt;{ }) 函数默认参数 1234function fn(name,age=17){ console.log(name+&quot;,&quot;+age);}fn(&quot;Amy&quot;); // Amy,17 不定参数 12345function f(...values){ console.log(values.length);}f(1,2); //2f(1,2,3,4); //4 箭头函数 function(){ ..... } ()=&gt;{}简写： 1、如果有且仅有一个参数，（）可不写 2、如果有且仅有一个语句并且是return，{}也可以不写 修正this 面向对象 class语言发展： 机器语言-&gt;汇编语言-&gt;低级语言（面向过程）-&gt;高级语言（面向对象）-&gt;模块系统-&gt;框架-&gt;系统接口（API） 封装 ES5面向对象（未标准化） 没有统一的写法 ES6面向对象（语法糖） 统一的写法继承： 1、省事 2、便于扩展 ES6新加： class 类声明 constructor 构造函数 extends 继承关键字 super 父类/超类 123456789101112131415161718192021222324class Person{ constructor(name,age){ this.name = name; this.age = age; } showName(){ console.log(this.name); }}let p = new Person();p.showName();class Worker extends Person{ constructor(name,age,job){ super(name,age); this.job = job; } showJob(){ console.log(this.job); }} 模块系统1、定义 12export let a= 12;export let b = 5; 2、使用 1、导出（export） //变量 export let a=1; //函数 export function show(){ …… } //类 export class Person{ ……. } //默认成员 export default …. ​ export {…} ​ 2、导入​ import * as model from xxx 引入所有成员​ import model from xxx 引入default成员​ import {a,b as name} from xxx​ //只引入，不使用​ import ‘xxx’​ //异步引入​ let p=import(xxxx)​ 3、webpack编译 (因暂时浏览器不支持模块化,所以是需要wp编译) babel编译 (向后适配)本地使用: 1、安装node 2、安装babel npm i @babel/core @babel/cli @babel/preset-env npm i @babel/polyfill 3、添加脚本 &quot;build&quot;:&quot;babel src -d dest&quot; //从src输出到dest 4、添加.babelrc配置文件 { &quot;presets&quot;:{ &quot;@babel/preset-env&quot; } } 5、执行编译 npm run build 异步操作:异步操作：同时进行多个操作，用户体验，es6之前代码混乱同步操作：一次只能进行一个操作，用户体验不好，代码清晰 异步的同步写法: 123456789101112131415161718192021222324252627Promise 1、封装异步操作 let p = new Promise(function(resolve,rejext){ $.ajex({ url:'', success(arr){ resolve(arr); }, error(res){ reject(res); } }); }); p.then(function(data){ console.log('成功了'); },function(res){ console.log('失败了'); }); 2、promise.all{[ //并行调用p1,p2 p1, p2, ... ]}.then 3、promise.race 竞速调用 123456789 async/await 普通函数——一直执行，直到结束 async函数——能够&quot;暂停&quot;async function show(){ ....; let data = await $.ajax(); //等待请求完成后继续执行 ....; }","link":"/2020/04/22/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Markdown常用语法","text":"第一章 块元素1.1标题标题有6个等级，用#号表示 1234567# 标题1## 标题2## 标题2### 标题2#### 标题4##### 标题5###### 标题6 1.2引用使用&gt;字符，表示引用 123&gt; This is a blockquote with two paragraphs. This is first paragraph.&gt; This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. This is a blockquote with two paragraphs. This is first paragraph.This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. 1.3列表12* red* blue red blue 121. red2. blue red blue 1.4任务列表用 [ ] 或者 [X] 未完成，完成）表示列表，通过点击复选框来更改状态（完成/未完成） 12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed a task list item list syntax required normal formatting, @mentions, #1234 refs incomplete completed 1.5代码块使用 ```&lt;语言&gt; 按回车键，将会对代码进行高亮 12345​```rubyrequire 'redcarpet'markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html​``` 123require 'redcarpet'markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html ###1.6数学 可以使用MathJax呈现LaTeX数学表达式 1234567$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\\\end{vmatrix}$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$ 1.7表格使用 | First Header | Second Header | 按回车键，将会创建2列的表格 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell 还可以使用 : 号，来设置文字对齐方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 ###1.8 脚注 1234使用 [^footnote] 创建脚注.You can create footnotes like this[^1].[^1]: Here is the *text* of the **footnote**.然后，可以把鼠标停留在脚注中，查看内容 You can create footnotes like this[^1].[^1]: Here is the text of the footnote. 1.10横线输入 *** 或者 — 后，按回车键 1.11目录输入 [toc] ，按回车键 [TOC] 第二章 Span元素2.1链接文字描述包含在 [] 内，链接地址包含在 () 内，() 要紧接着 [] 后面 12This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. This is an example inline link.This link has no title attribute. 2.1.1引用链接123[Bing][]And then define the link:[Bing]: http://bing.com/ BingAnd then define the link: 2.2图片123在链接格式前面添加 ! ，如下![在这里插入图片描述](http://pxebjkhug.bkt.clouddn.com/image-20190906161123468.png) 在链接格式前面添加 ! ，如下 ###2.3 强调 对应 HTML 的 标签 12*single asterisks*_single underscores_ single asterisks single underscores 如果像使用 * 号，在 * 号前使用 \\ 1\\*this text is surrounded by literal asterisks\\* *this text is surrounded by literal asterisks* 2.4加粗12**double asterisks**__double underscores__ double asterisksdouble underscores 2.5代码在文章中现实代码，用 ` 号表示 1Use the `printf()` function. Use the printf() function. 2.6删除线1~~Mistaken text.~~ Mistaken text. 2.7下划线1&lt;u&gt;Underline&lt;/u&gt; Underline ###2.8Emoji 表情 用两个 : 号包含单词，或者在 编辑 -&gt; 表情与符号 中选择 1:happy: :happy: 2.9高亮这个功能默认是关闭的，如果要打开这个功能（以 Mac 版本为例），选择 Typora -&gt; 偏好设置 -&gt; markdown 标签，勾选高亮复选框 1==highlight== ==highlight==","link":"/2019/09/10/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"title":"Node笔记","text":"一、Node1.1简介Node.js 是 JavaScript 的后端运行环境 Node.js官网 https://nodejs.org 查看node.js版本号中断指令 node –v 内置API fs 模块是 Node.js 官方提供的、用来操作文件的模块。 path 模块是 Node.js 官方提供的、用来处理路径的模块。 http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。 1.2 http创建最基本的web服务器 获取请求url 设置未处理的响应内容为404页面 判断用户请求的是否为/或/index.html首页 根据不同url响应不同的html内容 设置Content-Type响应头,防止中文乱码 使用res.end()把内容响应给客户端 二、模块化包管理指令 1.快速创建 package.json 1npm init -y 2.安装依赖包 12npm install //npm i 一次性安装项目依赖的所有包npm i 包名 //核心依赖包 会记录到dependencies节点 3.卸载制定的包 1npm uninstall 包名 4.安装只在项目开发阶段使用的包 12npm i 包名 -D等价于 npm install 包名 --save-dev 5.安装全局包 1npm i 包名 -g 切换下载源 nrm工具 123456全局安装nrm工具npm i nrm -g#查看所有可用的镜像源nrm ls切换镜像源nrm use taobao 开发自定义npm包 新建自定义包文件夹，作为根目录 在根目录新建如下3个文件： package.json (包管理配置文件) index.js (包的入口文件) README.md （包的说明文件） 创建功能模块 index.js导入功能模块，module.exports共享出去 发布包https://www.npmjs.com/ 1234//把包发布到npm,终端切换到包根目录执行npm publish删除已发布的包npm unpublish 包名 --force 三、Express1.使用是基于Node.js平台，构建的专门用来创建web服务器的http://www.expressjs.com.cn/ 常见的两种服务器： web网站服务器 api接口服务器 安装 项目目录运行如下命令： 1npm i express 创建基本的web服务器 托管静态资源 创建一个静态资源服务器，例如：通过如下代码将public目录下的资源对外开放访问，存放静态文件的目录不会出现在url中 1app.use(express.static('pubic)) 挂载路径前缀 1app.use('/public',express.static('pubic)) 2.路由路由就是映射关系，在express指的是客户端的请求和服务器处理函数之间的映射关系 express中路由有三部分组成，分别是请求的类型、请求的url地址、处理函数 1app.METHOD(PATH,HANDLER) 路由匹配过程 模块化路由使用 为路由模块添加前缀 1app.use('/api',userRouter) 3.中间件特指业务流程的中间处理环节。 express的中间件本质就是一个function处理函数 定义中间件函数 12345const mw = function (req,res,next) { console.log('这是一个简单地中间件函数') next() } 全局中间件 123app.use(function(req,res,next){ next()}) 局部中间件 12345678910111213141516171819202122const mw = function(req,res,next){ console.log('这是中间件函数') next()}app.get('/',mw,function(req,res){ res.send('home page')}) //mw不影响下面这个路由app.get('/user',function(req,res){ res.send('user page')}) //定义多个局部中间件 app.get('/',[nm1,nw2],(req,res){ res.send('') }) app.get('/',nm1,nw2,(req,res){ res.send('') }) 多个中间件共享同一份req和res 中间件使用注意事项 一定要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件处理 执行完中间件的业务代码后，不要忘记调用next()函数 防止代码逻辑，调用next()函数后不要再写额外的代码 连续调用多个中间件时，多个中间件之间，共享req和res对象 工具nodemon https://www.npmjs.com/package/nodemon 它能够监听node项目文件改动，当代吗修改后自动帮我们重启项目 1234//安装npm install -g nodemon//使用nodemon app.js 四、接口跨域问题解决方案 CORS(推荐) JSONP CORS CORS由一系列http响应头组成，这些http响应头决定浏览器是否组织前端js代码跨域获取资源。 使用cors步骤 npm install cors 安装中间件 const cors = require(‘cors’) 导入中间件 在路由之前调用 app.use(cors()) 配置中间件 JSONP 浏览器端通过 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据 的方式叫做 JSONP。 特点： ① JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。 ② JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求。 五、数据库1.1 简介数据库是用来组织、存储和管理数据的仓库 常见的数据库及分类 MySQL 数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise） Oracle 数据库（收费） SQL Server 数据库（收费） Mongodb 数据库（Community + Enterprise） 其中，MySQL、Oracle、SQL Server 属于传统型数据库（又叫做：关系型数据库 或 SQL 数据库），这三者的 设计理念相同，用法比较类似。 而 Mongodb 属于新型数据库（又叫做：非关系型数据库 或 NoSQL 数据库），它在一定程度上弥补了传统型 数据库的缺陷。 MySQL安装: https://dev.mysql.com/downloads/mysql/ MySQL Workbench：可视化的 MySQL 管理工具. 1.2 SQL结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形势，操作数据库里面的数据。 SQL是一门数据库编程语言 使用SQL语言编写出来的代码，叫做SQL语句 SQL语言只能在关键型数据库中使用（例如MySQL、Oracle、SQL Server）。非关系型数据库不支持SQL语言 1.3 项目中使用mysql 安装操作 MySQL 数据库的第三方模块（mysql） 1npm install mysql 通过 mysql 模块连接到 MySQL 数据库 123456789const mysql = require('mysql')const db = mysql.createPool({ host: 'localhost', user: 'root', password: 'admin123', database: 'api_server', port: 3306}) 通过 mysql 模块执行 SQL 语句 123456789const sql = `select 1`db.query(sql,(err,results) =&gt; { if(err) return res.send({status: 1, message:err.message}) res.send({ status: 0, message: '获取成功！', data: results })}) 六 前后端身份认证6.1 web开发模式主流有两种,分别是: 基于服务端渲染的传统 Web 开发模式: 服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的 基于前后端分离的新型 Web 开发模式: 后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式 服务端渲染的优缺点 优点： 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于SEO。 缺点： 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于 项目高效开发。 前后端分离的优缺点 优点： 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。 缺点： 不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！） 6.2 前后端身份认证身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。 不同开发模式下的身份认证 服务端渲染推荐使用 Session 认证机制 前后端分离推荐使用 JWT 认证机制 Session的工作原理 在 Express 项目中，可以安装 express-session 中间件 Session 认证的**局限性** Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证 注意： 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。 JWT的工作原理 在 Express 项目中，可以安装 jsonwebtoken 、 express-jwt 组件 使用JWT jsonwebtoken 用于生成 JWT 字符串 express-jwt 用于将 JWT 字符串解析还原成 JSON 对象","link":"/2022/04/22/Node%E7%AC%94%E8%AE%B0/"},{"title":"React学习笔记","text":"DAY1React生态圈jsx:拓展了js自身的语法,是react的基础 Flux:react的数据流组件 Redux:比flux更加简单、易用 React-Native:用react编写原生移动应用 jsx jsx是一门独立的语言,希望能改进js的很多问题,但是es6出现后,包含了jsx的大部分特性,所以很少独立使用 babel可以编译jsx react是基于jsx语法 提供模板式创建元素的方法 123456//普通元素创建let oDiv = document.createElement('div');odiv.title = 'aaa';oDiv.innerHTML = 'BBB';//jsx方式let oDiv = &lt;div title=&quot;aaa&quot;&gt;BBB&lt;/div&gt; 注意:jsx并不会真正创建dom元素,jsx只是解析模板语法,创建虚拟DOM节点,需经由ReactDOM渲染才会成为真正的DOM元素. 关于虚拟DOM 直接操作dom元素非常缓慢,所以很多框架(vue,react)都具备虚拟dom特性,我们直接操作的是虚拟dom,而非真正节点,react会在何时的实际批量更新dom节点(一般是主进程空闲时),从而提高性能. 能否单独使用jsx? 不能,react强依赖jsx用于解析jsx语法,但是jsx也强依赖react用于解析模板语法 第一个react程序 1234567891011121314//引入js文件 &lt;script src=&quot;js/browser.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/react-dom.js&quot;&gt;&lt;/script&gt; //容器 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; //react渲染,经过babel编译才能执行 &lt;script type=&quot;text/babel&quot;&gt; let root = document.getElementById('root'); ReactDOM.render(&lt;div&gt;aaa&lt;/div&gt;,root); &lt;/script&gt; 特殊属性 react中类”html代码”,其实不是真正的html,而是jsx语法,绝大部分标签与html一样,但是有两个属性需要修改 class:className for:htmlFor 单标签 react中单标签必须闭合(html标签和自定义组件都是) ; 错误 ; 正确 react组件组件 123456789101112131415161718 //组件定义 class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ let a = 12; let name = 'qpc'; let age = 18; return &lt;div&gt; &lt;span style={{color:'red'}}&gt;你好&lt;/span&gt; 姓名:{name} 年龄:{age}&lt;/div&gt;; } }//组件渲染 let root = document.getElementById('root'); ReactDOM.render(&lt;Cmp1 txt=&quot;qpc&quot;&gt;&lt;/Cmp1&gt;,root); 注意: 组件必须继承React.Component 组件必须有constructor()且super父级,否则状态等功能无法使用 组件必须有render()方法 组件类名必须首字母大写 组件使用时,单双标签都可以 组件中的html必须规范(双标签闭合,单标签结尾加/) 模板输出 输出变量、属性、方法、任何东西都可以 123456789101112131415161718192021222324252627class Cmp1 extends React.Component{ constructor(...args){ super(...args); this.age = 18; } fn(){ return 55; } render(){ let name = 'qpc'; let age = 18; const a = 66; return &lt;div&gt; &lt;span style={{color:'red'}}&gt;你好&lt;/span&gt; //输出变量 姓名:{name} //输出属性 年龄:{this.age} {this.fn()}; //输出到属性 &lt;div title={a}&gt;div2&lt;/div&gt; &lt;/div&gt;; } } 组件传参 用props接受参数 1234567891011class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ return &lt;div&gt; {this.props.a},{typeof(this.props.a)} &lt;/div&gt; } } 组件输出 123456789101112131415161718192021222324 class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ let spana = &lt;span&gt;aaa&lt;/span&gt; return &lt;div&gt; {spana} &lt;/div&gt; } }//输出一组元素 render(){ let arr = [ &lt;span key={0}&gt;aaa&lt;/span&gt;, &lt;span key={1}&gt;bbb&lt;/span&gt;, &lt;span key={2}&gt;ccc&lt;/span&gt; ]; return &lt;div&gt; {arr} &lt;/div&gt; } 关于key key非常重要，它关联虚拟dom和真实dom，从而在虚拟dom修改时对实际dom元素做最小化额修改以此提高性能，普通元素其实也有key，由react自己生成 注意：尽量不要用index作为key,因为index是会变化的（比如删掉一个元素，后续元素的index会变化） key的选择标准： 唯一：否则reactdom无法重用 不变：否则dom元素混乱 组件循环 12345678render(){ let arr = [1，2，3]; return &lt;div&gt; {arr.map((item,index) =&gt;( &lt;span key={index}&gt;{item}&lt;/span&gt; ))} &lt;/div&gt;} 组件嵌套 1234567891011121314151617181920212223242526272829303132333435363738class item extends React.Component{ constructor(...args){ super(...args); } render(){ return ( &lt;li&gt; {this.props.data} &lt;/li&gt; ) } }class list extends React.Component{ constructor(...args){ super(...args); } render(){ let arr = [1,2,3]; return ( &lt;ul&gt; {arr.map((n,index)=&gt;&lt;item key={index} data={n}&gt;&lt;/item&gt;)} &lt;/ul&gt; ) } }//输出一组元素 render(){ let arr = [ &lt;span key={0}&gt;aaa&lt;/span&gt;, &lt;span key={1}&gt;bbb&lt;/span&gt;, &lt;span key={2}&gt;ccc&lt;/span&gt; ]; return &lt;div&gt; {arr} &lt;/div&gt; } 组件状态 状态 属性是只读的，状态是可变的 状态的改变，组件会重新渲染 123456789101112131415161718192021class Cmp1 extends React.Component{ constructor(...args){ super(...args); //初始化状态 this.state={a:0}; } add(){ this.setState({ a:this.state.a+1 }); } render(){ return &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;加1&quot; onClick={thi.add.bind(this)}&gt;&lt;/input&gt; {this.state.a} &lt;/div&gt; } } 注意： 状态的初始化只能在constructor中完成 必须通过setState修改状态，否则也不能重新渲染——setState调用了render props变化引起重新渲染 强制渲染(forceUpdate) 组件生命周期 componentDidMount组件已经挂载 shouldComponentUpdate:即将开始更新组件，可以阻值更新发生 componentDidUpdate组件已更新 组件引用 ref：需用引用的组件 refs:父级中引用所有ref组件 实例：求和 12345678910111213141516171819202122class Cmp1 extends React.Component{ constructor(...args){ super(...args); //初始化状态 this.state={sum:0}; } fn(){ this.setState({ sum:parseInt(this.refs.num1.value)+parseInt(this.refs.num2.value) }); } render(){ return &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;num1&quot;/&gt; &lt;input type=&quot;text&quot; ref=&quot;num2&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;求和&quot; onClick={thi.fn.bind(this)}/&gt; {this.state.sum} &lt;/div&gt; } } 和vue有所不同，react中的ref不能重复，如果重复，后面的会覆盖掉前面的 组件通信 redux","link":"/2020/05/13/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"VUE基础","text":"Vue.js基础Vue (读音类似于 view) 是一套用于构建用户界面的渐进式框架 Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合 指令 本质就是自定义属性 Vue中指令都是以 v- 开头 内置指令 v-cloak 防止页面加载时出现闪烁问题 v-text v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题 如果数据中有HTML标签会将html标签一并输出 注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值 v-html 用法和v-text 相似 但是他可以将HTML片段填充到标签中 可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上 它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。 v-pre 显示原始信息跳过编译过程 跳过这个元素和它的子元素的编译过程。 一些静态的内容不需要编译加这个指令可以加快渲染 v-once 执行一次性的插值【当数据改变时，插值处的内容不会继续更新】 v-model v-model是一个指令，限制在 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;、components中使用 双向数据绑定 当数据发生变化的时候，视图也就发生变化 当视图发生变化的时候，数据也会跟着同步变化 v-on 用来绑定事件的 形式如：v-on:click 缩写为 @click; v-bind v-bind 指令被用来响应地更新 HTML 属性 v-bind:href 可以缩写为 :href; 条件判断 v-if 使用场景 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素 进行两个视图之间的切换 v-show 和 v-if的区别 v-show本质就是标签display设置为none，控制隐藏 v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。 v-if是动态的向DOM树内添加或者删除DOM元素 v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件 循环结构 v-for 用于循环的数组里面的值可以是对象，也可以是普通元素 key 的作用 key来给每个节点做一个唯一标识 key的作用主要是为了高效的更新虚拟DOM 自定义指令 介绍 -内置指令不能满足我们特殊的需求 Vue允许我们自定义指令 Vue.directive 注册全局指令 Vue.directive 注册全局指令 带参数 自定义指令局部指令 局部指令，需要定义在 directives 的选项 用法和全局用法一样 局部指令只能在当前组件里面使用 当全局指令和局部指令同名时以局部指令为准 修饰符事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。 Vue 不推荐我们操作DOM 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符 -修饰符是由点开头的指令后缀来表示的 按键修饰符 在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符 自定义按键修饰符别名 在Vue中可以通过config.keyCodes自定义按键修饰符别名 表单修饰符 .number 转换为数值 注意点 当开始输入非数字的字符串时，因为Vue无法将字符串转换成数值 所以属性值将实时更新成相同的字符串。即使后面输入数字，也将被视作字符串。 .trim 自动过滤用户输入的首尾空白字符 只能去掉首尾的 不能去除中间的空格 .lazy 将input事件切换成change事件 .lazy 修饰符延迟了同步更新属性值的时机。即将原本绑定在 input 事件的同步逻辑转变为绑定在 change 事件上 在失去焦点 或者 按下回车键时才更新 计算属性 computed 模板中放入太多的逻辑会让模板过重且难以维护 使用计算属性可以让模板更加的简洁 计算属性是基于它们的响应式依赖进行缓存的 computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化 侦听器watch使用watch来响应数据的变化 一般用于异步或者开销较大的操作 watch 中的属性 一定是data 中 已经存在的数据 当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听 过滤器介绍 Vue.js允许自定义过滤器，可被用于一些常见的文本格式化 使用场景 过滤器可以用在两个地方：双花括号插值和v-bind表达式。 过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示 支持级联操作 注意点 过滤器不改变真正的data，而只是改变渲染的结果，并返回过滤后的版本 全局注册时是filter，没有s的。而局部过滤器是filters，是有s的 过滤器中传递参数生命周期介绍 事物从出生到死亡的过程 Vue实例从创建 到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数 生命周期钩子函数 组件介绍 组件 (Component) 是 Vue.js 最强大的功能之一 组件可以扩展 HTML 元素，封装可重用的代 组件注册 全局注册 Vue.component(‘组件名称’, { }) 第1个参数是标签名称，第2个参数是一个选项对象 全局组件注册后，任何vue实例都可以用 用法 注意事项 组件参数的data值必须是函数同时这个函数要求返回一个对象 组件模板必须是单个根元素 组件模板的内容可以是模板字符串 局部注册 只能在当前注册它的vue实例中使用 Vue组件之间传值 父组件向子组件传值 父组件发送的形式是以属性的形式绑定值到子组件身上。 然后子组件用属性props接收 在props中使用驼峰形式，模板中需要使用短横线的形式字符串形式的模板中没有这个限制 子组件向父组件传值 子组件用$emit()触发事件 $emit() 第一个参数为 自定义的事件名称 第二个参数为需要传递的数据 父组件用v-on 监听子组件的事件 兄弟之间的传递 兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据 提供事件中心 var hub = new Vue() 传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 接收数据方，通过mounted(){} 钩子中 触发hub.$on()方法名 销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据 组件插槽 介绍 组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力 匿名插槽 具名插槽 具有名字的插槽 使用 中的 “name” 属性绑定元素 作用域插槽 父组件对子组件加工处理 既可以复用子组件的slot，又可以使slot内容不一致 路由概念 路由的本质就是一种对应关系，比如说我们在url地址中输入我们要访问的url地址之后，浏览器要去请求这个url地址对应的资源。那么url地址和真实的资源之间就有一种对应的关系，就是路由。 路由分为前端路由和后端路由 1).后端路由是由服务器端进行实现，并完成资源的分发 后端路由性能相对前端路由来说较低，所以，我们接下来主要学习的是前端路由 2).前端路由是依靠hash值(锚链接)的变化进行实现 前端路由的基本概念：根据不同的事件来显示不同的页面内容，即事件与事件处理函数之间的对应关系 前端路由主要做的事情就是监听事件并分发执行事件处理函数 Vue Router 简介 它是一个Vue.js官方提供的路由管理器。是一个功能更加强大的前端路由器，推荐使用。Vue Router和Vue.js非常契合，可以一起方便的实现SPA(single page web application,单页应用程序)应用程序的开发。 Vue Router依赖于Vue，所以需要先引入Vue，再引入Vue Router Vue Router的特性： 支持H5历史模式或者hash模式 支持嵌套路由 支持路由参数 支持编程式路由 支持命名路由 支持路由导航守卫 支持路由过渡动画特效 支持路由懒加载 支持路由滚动行为 Vue Router的使用步骤 1、导入js文件 2、添加路由链接:是路由中提供的标签，默认会被渲染为a标签，to属性默认被渲染为href属性，to属性的值会被渲染为#开头的hash地址 User 3、添加路由填充位（路由占位符） 4、定义路由组件 var User = { template:”This is User“ } 5、配置路由规则并创建路由实例 var myRouter = new VueRouter({//routes是路由规则数组routes:[ //每一个路由规则都是一个对象，对象中至少包含path和component两个属性 //path表示 路由匹配的hash地址，component表示路由规则对应要展示的组件对象 {path:”/user”,component:User}, {path:”/login”,component:Login}]}) 6、将路由挂载到Vue实例中 new Vue({el:”#app”,//通过router属性挂载路由对象router:myRouter}) 补充： 路由重定向：可以通过路由重定向为页面设置默认展示的组件在路由规则中添加一条路由规则即可，如 var myRouter = new VueRouter({//routes是路由规则数组routes: [//path设置为/表示页面最初始的地址 / ,redirect表示要被重定向的新地址，设置为一个路由即可{ path:”/“,redirect:”/user”},{ path: “/user”, component: User },{ path: “/login”, component: Login }]}) 分类 嵌套路由 嵌套路由最关键的代码在于理解子级路由的概念：比如我们有一个/login的路由那么/login下面还可以添加子级路由，如:/login/account/login/phone 动态路由 补充： 1.我们可以通过props来接收参数 2、还有一种情况，我们可以将props设置为对象，那么就直接将对象的数据传递给组件进行使用 3、如果想要获取传递的参数值还想要获取传递的对象数据，那么props应该设置为函数形式。 命名路由 给路由取别名 编程式导航 调用js的api方法实现导航 this.$router.push(“hash地址”); this.$router.push(“/login”); this.$router.push({ name:’user’ , params: {id:123} }); this.$router.push({ path:”/login” }); this.$router.push({ path:”/login”,query:{username:”jack”} }); this.$router.go( n );//n为数字，参考history.go this.$router.go( -1 );","link":"/2020/10/10/VUE%E5%9F%BA%E7%A1%80/"},{"title":"WIFI配网方案","text":"WIFI配网方案：1、蓝牙配网 2、WIFI自身配网 3、SmartConfig一键配网 蓝牙配网：顾名思义，通过蓝牙给WIFI配网，过程相对较为简单，首先设备上具有WIFI和蓝牙两种功能。然后通过手机的小程序或者APP连接产品蓝牙，连接之后发送WIFI连接所需要的SSID和PASSID。产品接收到蓝牙信息后，产品WIFI通过SSID和PASSID去进行WIFI的连接。 流程示意图： WIFI自身配网：此过程也比较简单，首先设置当前WIFI为AP+STA模式。然后通过手机的小程序或者APP连接上产品在AP模式下的WIFI。连接之后发送产品需要连接的WIFI的SSID和PASSID。产品接收到SSID和PASSID信息后，产品WIFI通过SSID和PASSID去进行WIFI的连接。 流程示意图： SmartConfig一键配网：1、手机的APP或者小程序先连接上一个现场的局域网网络也就是一个WIFI。 2、被配网的设备需要开启混杂模式。混杂模式又叫偷听模式，允许节点接收它能侦听到的所有数据包。 3、手机的APP或者小程序通过连接的局域网WIFI，进行UDP数据的广播或者组播进行一个循环发送，数据包里面包含了需要连接WIFI的SSID和PASSID。 4、被配网的设备通过 UDP 包（长度）获取配置信息捕捉到 需要连接WIFI的SSID和PASSID，最后连接路由器。（广播根据 UDP 包长度，组播根据 IP 地址信息） 流程示意图： 知识扩展： 1、TCP和UDP连接过程：TCP编程的服务器端一般步骤是：1、创建一个socket，用函数socket()；2、设置socket属性，用函数setsockopt(); * 可选3、绑定IP地址、端口等信息到socket上，用函数bind();4、开启监听，用函数listen()；5、接收客户端上来的连接，用函数accept()；6、收发数据，用函数send()和recv()，或者read()和write();7、关闭网络连接；8、关闭监听； TCP编程的客户端一般步骤是：1、创建一个socket，用函数socket()；2、设置socket属性，用函数setsockopt();* 可选3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选4、设置要连接的对方的IP地址和端口等属性；5、连接服务器，用函数connect()；6、收发数据，用函数send()和recv()，或者read()和write();7、关闭网络连接； UDP编程的服务器端一般步骤是：1、创建一个socket，用函数socket()；2、设置socket属性，用函数setsockopt();* 可选3、绑定IP地址、端口等信息到socket上，用函数bind();4、循环接收数据，用函数recvfrom();5、关闭网络连接； UDP编程的客户端一般步骤是：1、创建一个socket，用函数socket()；2、设置socket属性，用函数setsockopt();* 可选3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选4、设置对方的IP地址和端口等属性;5、发送数据，用函数sendto();6、关闭网络连接； 2、单播、广播、组播1、单播：单台主机与单台主机之间的通信； 2、广播：单台主机与网络中所有主机的通信； 3、组播（多播）：单台主机与选定的一组主机的通信； 多播首先要知道的是只有UDP有多播，没有TCP多播。因为多播的重点是高效的把同一个包尽可能多的发送到不同的，甚至可能是未知的设备。但是TCP连接可能要求丢包重发或者延时或重组顺序，这些操作可能非常消耗资源，不适于许多使用多播的应用场景。（同时多播不知道发出的包是不是已经到达，这个也导致不能使用TCP）。 同样广播也是属于UDP，TCP属于端对端的通信，通信要求比较严格。 ©著作权归作者所有：来自51CTO博客作者浮若于心的原创作品，https://blog.51cto.com/u_15427821/4581200","link":"/2022/06/23/WIFI%E9%85%8D%E7%BD%91%E6%96%B9%E6%A1%88/"},{"title":"app启动优化","text":"启动分类: 1.冷启动: 从用户点击App图标开始到appDelegate didFinishLaunching方法执行完成为止。这是一次完整的启动过程。 2.热启动:App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 启动主要步骤: T1：main()函数之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载&amp;链接等工作，最后执行至App的main()函数。 T2：main()函数之后，即从main()开始，到appDelegate的didFinishLaunchingWithOptions方法执行完毕。 T3:当didFinishLaunchingWithOptions执行完成时，用户还没有看到App的主界面，也不能开始使用App。这个阶段会一般会首页渲染和数据请求后，用户才能真正看到主页面。 T1阶段及优化 阶段 工作 加载动态库 Dyld从主执行文件的header获取到需要加载的所依赖动态库列表，然后它需要找到每个 dylib，而应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以所需要加载的是动态库列表一个递归依赖的集合 Rebase和Bind - Rebase在Image内部调整指针的指向。在过去，会把动态库加载到指定地址，所有指针和数据对于代码都是对的，而现在地址空间布局是随机化，所以需要在原来的地址根据随机的偏移量做一下修正 - Bind是把指针正确地指向Image外部的内容。这些指向外部的指针被符号(symbol)名称绑定，dyld需要去符号表里查找，找到symbol对应的实现 Objc setup - 注册Objc类 (class registration) - 把category的定义插入方法列表 (category registration) - 保证每一个selector唯一 (selector uniquing) Initializers - Objc的+load()函数 - C的构造函数属性函数 - 非基本类型的C静态全局变量的创建(通常是类或结构体) 优化： 1.减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司建议最多使用 6 个非系统动态库。 2.减少无用类和方法，代码瘦身 3.+load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。 4.控制 C++ 全局变量的数量 T2阶段及优化 这个阶段在我看来主要是didFinishLaunchingWithOptions里面代码的执行： 优化： 分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段 T3阶段及优化 主界面的构建 优化： 1.优化耗时操作：这个就要分析代码中是否存在图片I/O、图片解码、archive文档等隐含着一些耗时操作； 2.优化串行操作。 启动速度监控工具 1.查看T1阶段时间 通过添加环境变量可以打印出APP的T1启动时间分析（Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Arguments-&gt;Environment Variables-）DYLD_PRINT_STATISTICS设置为1； 如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1。 2.查看T1之后耗时 方案一:定时抓取主线程方法的调用堆栈，计算一段时间里的方法耗时。（Xcode中的Time Profiler就是使用的这种的方法） 方案二:对objc_msgSend方法进行hook，来得到所有方法的耗时。 方案二工具实现https://github.com/QiShare/Qi_ObjcMsgHook 参考文章: https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html https://time.geekbang.org/column/article/85331","link":"/2021/03/24/app%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"},{"title":"hexo博客搭建教程","text":"###简介 Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。 ###安装 因自己使用的mac电脑，这里以mac安装发布为例，windows大体差不多。 1.1电脑本地创建一个文件夹，例如我这里的blog。 1.2 打开电脑终端执行以下命令： 12$npm install -g hexo-cli$ hexo init 如果npm指令出现此报错zsh: command not found: node,需安装nodejs环境,下载链接 1.3 安装完成后，指定文件夹的目录如下 ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds是存放模板的文件夹，当新建文章时，Hexo会根据scaffold来建立文件；source是资源文件夹，用于存放用户资源，themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。 1.4生成静态博客，在终端执行命令： 1hexo s Hexo将source文件夹中的Markdown 和 HTML 文件会被解析并放到public文件夹中，public文件夹用于存放静态博客文件，相当于网站根目录。至此博客雏形基本完成，在浏览器中访问http://localhost:4000/，如图所示： 2.1主题更换 前往主题页，选择喜欢的主题： 2.2 挑选喜欢的主题后，将主题clone到blog的themes文件夹下 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 2.3 修改_config.yml中对应的主题字段为你选择的主题名 到此主题更换成功，可以本地hexo s本地看看是否替换成功。 3.1发布到github 可以参看这篇文章：怎么把Hexo的博客托管到Git上 4.常用hexo命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 指令缩写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令 12hexo s -g #生成并本地预览hexo d -g #生成并上传 5.Hexo博客多端同步解决办法 6.自定义域名绑定篇","link":"/2019/09/06/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"title":"iOS逆向笔记","text":"逆向环境搭建iPhone越狱操作pp助手 爱思助手(一键越狱未成功) 刚开始使用unc0ver对几款iphone进行越狱安装后均显示不支持,所以改用checkra1n 先将官网放上https://checkra.in/ 刚开始用的官网下载的0.9.8.2刷机均中途报错 Exploit Failed (Error code: -31) 或 Timed out waiting for bootstrap upload(Likely caused by an incompatible tweak, to enable Safe Mode check the option on main screen) (Error code: -20) 后搜到这篇文章,看到有0.10.0版本的过段换最新的试试. https://mrmad.com.tw/checkra1n 最后贴上越狱成功下载地址 [v0.10.0 Beta](https://assets.checkra.in/test/checkra1n beta 0.10.0.dmg) mac远程登录iPhone通过ssh让mac远程登录iphone 1.手机端安装Cydia安装openssh工具 2.使用查看插件descrition中的描述 3.确保mac和iphone在同一局域网下,在mac的终端输入ssh 账户名@服务器主机地址 例如ssh root@10.1.1.168 (初始密码一般为alpine) 4.退出连接 exit 相关拓展: iOS下有2个常用账户:root/mobile root:最高权限账户,$HOME是/var/root mobile:普通权限账户,只能操作一些普通文件,不能操作系统级别的文件,$HOME是/var/mobile 修改登录密码 passwd 修改root密码 Passwd mobile 修改mobile用户密码 参考文章链接 Cycript通过cydia安装cycript可在iphone上调试运行中的app 常用指令 开启 cycript cycript -p 进程ID cycript -p 进程名称 取消输入: Ctrl + C 退出: Ctrl + D 清屏:Command + R 常用语法 UIApp 获取app对象 #内存地址 用内存地址获取对象 ObjectiveC.classes 已加载的所有OC类 *对象 查看对象的所有成员变量 view.recursiveDescription().toString() 递归打印view的所有子控件 choose(UITableViewCell) 筛选出某种类型的对象 mj工具类 ps命令手机安装adv-cmds插件 使用ps命令可以列出系统当前的进程 列出所有的进程 ps -A ps aux 搜索关键词 ps -A|grep 关键词 Reveal界面调试工具可以用其找到对应要操作视图类 Mach-O Class-dump对Mach-o文件进行静态分析,导出对应的头文件 导出指令 Class-dump -H Mach-O 文件路径 -o 头文件存放目录 -H表示要生成头文件 -o用于制定头文件的存放目录 头文件导出,可导出oc,swift过滤 http://stevenygard.com/projects/class-dump/ 参考 脱壳加壳是通过特殊算法,对可执行文件的编码进行改变(比如压缩/加密),以达到保护程序代码的目的. 脱壳就是将未加密的文件还原出来. 手机安装crackerXI插件,获取脱壳后文件,使用ifunbox将其导出. TWeak实战实战课参考此文章","link":"/2020/04/09/app%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/"},{"title":"iOS与硬件打交道-NSMutableData NSData Byte的使用","text":"NSMutableData12345678910111213- (void)appendBytes:(const void *)bytes length:(NSUInteger)length;//跟原来的数据进行拼接数据- (void)appendData:(NSData *)other;//将接收器的长度增加给定的字节数- (void)increaseLengthBy:(NSUInteger)extraLength;//删除- (void)replaceBytesInRange:(NSRange)range withBytes:(const void *)bytes;//清空数据- (void)resetBytesInRange:(NSRange)range;//覆盖原有数据- (void)setData:(NSData *)data;- //删除- (void)replaceBytesInRange:(NSRange)range withBytes:(nullable const void *)replacementBytes length:(NSUInteger)replacementLength; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//把byte数组数据添加到DataByte byte[] = {0x01,0x02,0x03,0x04,0x05,0x06};NSData *byteData = [[NSData alloc] initWithBytes:byte length:6];//0x010203040506NSLog(@&quot;byteData:%@&quot;,byteData);//byteData:{length = 6, bytes = 0x010203040506}//把Data数据添加到NSMutableDataNSMutableData *muData = [NSMutableData data];[muData appendData:byteData];NSLog(@&quot;muData:%@&quot;,muData);//muData:{length = 6, bytes = 0x010203040506}//将接收器的长度增加给定的字节数[muData increaseLengthBy:4];NSLog(@&quot;muData:%@&quot;,muData);//muData:{length = 6, bytes = 0x010203040506}// add 添加Byte byteT[] = {0x07};NSData *byteData_0 = [[NSData alloc] initWithBytes:byteT length:1];[muData appendData:byteData_0];//添加0x07到最后面NSLog(@&quot;muData:%@&quot;,muData);//muData:{length = 7, bytes = 0x01020304050607// delete 删除[muData replaceBytesInRange:NSMakeRange(0, 1) withBytes:NULL length:0];//删除第一位NSLog(@&quot;muData:%@&quot;,muData);//muData:{length = 6, bytes = 0x020304050607}//insert 插入Byte byte_1[] = {0x08};NSData *byteData_1 = [[NSData alloc] initWithBytes:byte_1 length:1];[muData replaceBytesInRange:NSMakeRange(0, 0) withBytes:byteData_1.bytes length:byteData_1.length];//把0x08插入到最前面NSLog(@&quot;muData:%@&quot;,muData);//muData:{length = 7, bytes = 0x08020304050607}//清空数据[muData resetBytesInRange:NSMakeRange(0, [muData length])];[muData setLength:0];NSLog(@&quot;muData:%@&quot;,muData);Byte byte[] = {0x01,0x02,0x03,0x04,0x05,0x06};NSData *byteData = [[NSData alloc] initWithBytes:byte length:6];NSLog(@&quot;byteData:%@&quot;,byteData);//byteData:{length = 6, bytes = 0x010203040506}//appendData 在原来的数据上进行拼接NSMutableData *muData = [NSMutableData data];[muData appendData:byteData];[muData appendData:byteData];NSLog(@&quot;muData:%@&quot;,muData);//muData:{length = 12, bytes = 0x010203040506010203040506}[muData setData:byteData];NSLog(@&quot;muData:%@&quot;,muData);//muData:{length = 6, bytes = 0x010203040506}//setData 会覆盖原来的数据Byte byte[] = {0x01,0x02,0x03,0x04,0x05,0x06};NSData *byteData = [[NSData alloc] initWithBytes:byte length:6];NSLog(@&quot;byteData:%@&quot;,byteData);//byteData:{length = 6, bytes = 0x010203040506} NSData12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//构造空的NSData对象。+ (instancetype)data;//初始化- (instancetype)initWithBytesNoCopy:(void *)bytes length:(NSUInteger)length freeWhenDone:(BOOL)b;//初始化对象。不进行复制字节数组操作，直接设置字节指针为bytes，长度为length。- (instancetype)initWithBytesNoCopy:(void *)bytes length:(NSUInteger)length;//初始化对象。 复制字节数组，设置字节指针指向复制的字节数组，长度为length。- (instancetype)initWithBytes:(nullable const void *)bytes length:(NSUInteger)length;//读取文件内容初始化对象。 读取成功则返回对象，如果失败则返回nil。- (nullable instancetype)initWithContentsOfFile:(NSString *)path;//读取文件内容初始化对象。 //读取成功则返回对象。如果失败则返回nil，错误信息保存在errorPtr中。 参数readOptionsMask 指定文件读取选项。- (nullable instancetype)initWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;typedef NS_OPTIONS(NSUInteger, NSDataReadingOptions) { NSDataReadingMappedIfSafe = 1UL &lt;&lt; 0, NSDataReadingUncached = 1UL &lt;&lt; 1, NSDataReadingMappedAlways = 1UL &lt;&lt; 3, NSDataReadingMapped = NSDataReadingMappedIfSafe, NSMappedRead = NSDataReadingMapped, NSUncachedRead = NSDataReadingUncached};//读取url内容初始化对象。读取成功则返回对象，如果失败则返回nil。- (nullable instancetype)initWithContentsOfURL:(NSURL *)url;//读取url内容初始化对象。 //读取成功则返回对象。如果失败则返回nil，错误信息保存在errorPtr中。 参数readOptionsMask 指定文件读取选项。- (nullable instancetype)initWithContentsOfURL:(NSURL *)url options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;//根据NSData对象初始化对象。- (instancetype)initWithData:(NSData *)data;//根据文件内容初始化对象。读取文件内容的方式不是read系统调用，而是mmap系统调用- (nullable id)initWithContentsOfMappedFile:(NSString *)path//返回长度@property (readonly) NSUInteger length;//返回数据@property (readonly) const void *bytes//参数buffer保存获取的数据，参数range指定获取数据的区间。- (void)getBytes:(void *)buffer range:(NSRange)range;//获取指定长度的数据。如果length大于数据长度，则使用数据长度作为指定长度。- (void)getBytes:(void *)buffer length:(NSUInteger)length;//获取所有数据。- (void)getBytes:(void *)buffer//截取数据- (NSData *)subdataWithRange:(NSRange)range;//比较数据是否相等- (BOOL)isEqualToData:(NSData *)other; 123456789101112131415161718192021222324//Byte数据转换成DataByte byte[] = {0x01,0x02,0x03,0x04,0x05,0x06};NSData *byteData = [[NSData alloc] initWithBytes:byte length:6];NSLog(@&quot;byteData:%@&quot;,byteData);//读取桌面的test.txt的文件数据 读取回来是二进制的NSString *filePath = [NSHomeDirectory() stringByAppendingString:@&quot;/Desktop/test.txt&quot;];NSData *data5 = [[NSData alloc] initWithContentsOfFile:filePath];NSData *data6 = [NSData dataWithContentsOfFile:filePath];NSLog(@&quot;data5: %@&quot;,data5);NSLog(@&quot;data6: %@&quot;,data6);//把url转换成二进制NSURL *urlPath = [NSURL URLWithString:[@&quot;file://&quot; stringByAppendingString:[NSHomeDirectory() stringByAppendingString:@&quot;/Desktop/test.txt&quot;]]];NSData *data7 = [[NSData alloc] initWithContentsOfURL:urlPath];NSData *data8 = [NSData dataWithContentsOfURL:urlPath];NSLog(@&quot;data7: %@&quot;,data7);NSLog(@&quot;data8: %@&quot;,data8);//获取data的指定范围// 定义一个长度为100的数组char buffer[100];// 将NSData指定范围的数据读入数组[data8 getBytes:buffer range: NSMakeRange(103, 100)]; Byte跟UInt8是一样的1234567Byte byte[] = {0x01,0x02,0x03,0x04,0x05,0x06};NSData *byteData = [[NSData alloc] initWithBytes:byte length:6];NSLog(@&quot;byteData:%@&quot;,byteData);UInt8 byteUInt8[] = {0x01,0x02,0x03,0x04,0x05,0x06};NSData *byteUInt8Data = [NSData dataWithBytes:byteUInt8 length:6];NSLog(@&quot;byteUInt8Data: %@&quot;,byteUInt8Data);","link":"/2022/06/24/iOS%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%89%93%E4%BA%A4%E9%81%93-NSMutableData-NSData-Byte%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"iOS性能优化","text":"一、静态分析Xcode 自带的静态分析工具 Analyze，通过静态语法分析能够找出在代码层面就能发现的内存泄露问题，还可以通过上下文分析出是否存在变量无用等问题。但是，Analyze 的功能还是有限，还是无法帮助我们在编写代码的阶段发现更多的问题。所以，这才诞生出了功能更全、定制化高、效率高的第三方静态检查工具。比如OCLint、Infer等 Analyze分析参考文章： Analyze静态分析 Infer静态分析工具使用： https://www.cnblogs.com/ZachRobin/p/11280499.html 二、包大小瘦身2.1删除无用资源图片资源优化 1.删除无用图片 使用插件：https://github.com/tinymind/LSUnusedResources 2.图片资源压缩 部分图片采用webp格式 图片压缩工具：https://tinypng.com/ 2.2代码瘦身 感谢踩坑小分队提供的瘦身py脚本系列工具集：https://www.jianshu.com/p/bde52cc0b5d5 如果工程量不是很大的话，可以使用 AppCode 来做分析，用 AppCode 做分析的方法很简单，直接在 AppCode 里选择 Code-&gt;Inspect Code 就可以进行静态分析。 **** 无用类查找 python FindClassUnRefs.py -p /Users/pengchengqin/Library/Developer/Xcode/DerivedData/-fdgdsseeslsaryblrnxopmyfmdwl/Build/Products/Debug-iphoneos/.app -b Pod,AF,SD,BM,MJ,JX,FM,IQ 三、线下性能分析工具Instruments 四、app崩溃日志信息监控代码线上埋点分析：bugly (https://bugly.qq.com/) 五、卡顿原因及优化在屏幕成像的过程中，CPU和GPU起着至关重要的作用 CPU（Central Processing Unit，中央处理器） 对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics） GPU（Graphics Processing Unit，图形处理器） 纹理的渲染 卡顿原因 卡顿优化（CPU方面） 尽量用轻量级的对象，用不到时间处理的地方可以，可以使用CALayer取代UIView 不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性 Autolayout会比直接设置frame消耗更多的CPU资源 图片的size最好刚好跟UIImageView的size保持一致 控制一下线程的最大并发数量 尽量把耗时的操作放到子线程 文本处理（尺寸计算、绘制） 图片处理（解码、绘制） 卡顿优化（GPU方面） 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图数量和层次 减少透明的视图（alpha&lt;1），不透明的就设置opaque为YES 尽量避免出现离屏渲染 离屏渲染 在OpenGL中，GPU有2种渲染方式 On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作 Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作 离屏渲染消耗性能的原因： 需要创建新的缓冲区 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕 哪些操作会触发离屏渲染？ 光栅化，layer.shouldRasterize = YES 遮罩，layer.mask 圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0 可以考虑通过CoreGraphics绘制裁剪圆角，或者美工提供圆角图片 阴影，layer.shadowXXX 如果设置了layer.shadowPath就不会产生离屏渲染 六、耗电优化耗电主要来源： 少用定时器 优化I/O操作 尽量不要频繁写入小数据，最好批量一次性写入 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问 数据量比较大的，建议使用数据库（比如SQLite、CoreData） 网络优化 减少、压缩网络数据 ，能缓存数据尽量缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载 定位优化 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion: 硬件检测优化 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件 参考文章：iOS耗电量优化实践（https://www.jianshu.com/p/bd2c1ce5c02a）","link":"/2021/01/22/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"iOS知识点整理","text":"一、最佳实践 在类的头文件中尽量少引用其他头文件； 多用字面量语法，少用与之等价的方法； 多用类型常量，少用#define预处理指令； 用枚举表示状态、选项、状态码； 二 快捷键 Command + R 运行 Command + . 停止 Control + i 讲选中的代码格式化 Command + control+ 上下箭头键 切换头文件和m. 文件 Command + control+ 左箭头 回退，回到你上次打开的页面 零碎知识点唐巧推荐提高篇:https://blog.devtang.com/2014/07/27/ios-levelup-tips/ 1.1.iOS 静态库，动态库与 Framework 1.2从xib中自定义view的最佳姿势 1.3 iOS15 导航器适配记录https://www.jianshu.com/p/366852d6c87b 1.4 UITableView 分组高度显示异常处理方案http://events.jianshu.io/p/e33a5576a81b 1.5 ios15适配汇总 https://www.jianshu.com/p/3e1f0ce35bd5 1.6 在Xib中进行UIScrollView布局 1.7 NSURLProtocol 应用场景 1.8 NSURLProtocol进行网络拦截 1.9 crc校验 几种CRC16计算公式、初始值、标志位等参数汇总 2.1 UIViewController 的生命周期 2.2 企业应用包部署到个人服务器 2.3 iOS如何完美的修改项目名称 2.4 pod install 报错 出现 “Failed to connect to github.com port 443: Operation timed out”解决方案 2.5 UIPageViewController使用 2.6 http三次握手四次挥手 2.7 Charles 功能介绍和使用教程 charles抓包显示乱码解决方法 2.8 Jenkins 实现 iOS 项目自动打包 组件化iOS组件化拆分https://www.jianshu.com/p/760d6cd46719 关于私有pod库依赖私有库 https://juejin.cn/post/6844903856854450184 面试常备Swift 中Class 和 Struct 的区别(类和结构体)https://juejin.cn/post/6844903894762389512 深浅拷贝https://www.cnblogs.com/beckwang0912/p/7212075.html pod install与pod update的区别https://juejin.cn/post/6844903639966826510 masonry 修改约束动画https://juejin.cn/post/6844903544911314957 面试知识整理https://hit-alibaba.github.io/interview/https://juejin.cn/post/6908303868086452237https://github.com/miniLV/Interview-series","link":"/2020/09/18/iOS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"},{"title":"iOS线上crash日志分析","text":"因为线上统计用的百度sdk,现在记录下针对百度错误日志的手动分析方法,其官网文档有自动和手动分析两种方法. 这里记录一下自己手动定位crash报错方法的流程: 百度移动统计iOS SDK获取的crash日志不是完整的系统生成日志，其内容主要包括异常类型、原因、Backtrace调用等. SDK V3.5及以上的SDK，日志格式会在头部新增相关信息，如下: 1234UUID: 538572BD-D973-3D55-A475-4579BA0BECBFNAME: BaiduMobStatSampleARCH: x86_64ADDR: 0x100000000 bug分析命令：**xcrun atos –arch arm64 -o +包路径 -l 基地址 + 偏移地址** 1、获取包路径 （1）XCode-&gt;Window-&gt;Organizer （2）找到对应的安装包并双击点击show in Finder （3）双击.xcarchive文件显示包内容 （4）双击.app.dsYM文件显示报内容 （5）按照如下路径找到APP名字的文件 （6）打开终端输入(xcrun atos -arch arm64 -o )然后（将appname文件拖到此处，如下图） （7）输入（-l）+ (崩溃日志中的ADDR如下图) + （APPname后面对应的一串字符如下图的蓝圈内的地址）输入完成之后回车就可以了 8、最终结果如下，会解析出类名，和报错的行数","link":"/2020/07/27/iOS%E7%BA%BF%E4%B8%8A%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%88%86%E6%9E%90/"},{"title":"iOS蓝牙知识整理","text":"最近又要捣鼓一下蓝牙文件传输,想把之前总结漏掉的在重新整理下,搜索和连接等基本操作之前的这篇好了,这次主要做一下补充 Bluetooth蓝牙篇（BLE） 推荐参考文章: iOS蓝牙知识快速入门","link":"/2021/05/26/iOS%E8%93%9D%E7%89%99%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"title":"protobuf iOS使用","text":"为什么使用protobuf 在不同平台通信的时候，首先需要将对象进行序列化。iOS平台上我们常用NSKeyedArchiver进行归档，当然也可以将数据处理为JSON或者XML格式。NSKeyedArchiver只能在iOS/Mac平台使用，因此它归档的二进制数据不适合于在不同平台之间使用。JSON和XML虽然由于容易维护，易读而应用比较广泛，但是对数据的利用效率都不是高。这时候该使用Protobuf了,因为Protobuf的优势是效率高，同样的一份数据使用protobuf存储的时候更小，更加方便 Protobuf是什么 Protobuf 即 google protocol buffer 是一种数据封装格式协议,是google推出的一种语言无关、平台无关、扩展性好的用于通信协议、数据存储的结构化数据串行化方法。 使用Protobuf大致分三步: 1.集成protoc工具 2.根据自己的需求创建proto文件并转换 3.向自己的项目集成protocbuf 一、集成protoc环境1.下载protoc项目2.生成protoc编译器cd到下载目录，终端依次执行以下命令 12345./autogen.sh./configuremakesudo make installobjectivec/DevTools/full_mac_build.sh 成功后在src文件夹下会有个protoc文件 二、使用protoc转换文件1.根据需求新建后缀为proto的文件,例: XXXX.proto 2.转换1protoc --proto_path=路径1 --objc_out=路径2 XXXX.proto 路径1 : 创建的proto文件所在目录 路径2 : 转换后的文件输出路径 XXXX.proto : 创建的proto文件名称 例: 在桌面创建放proto文件的文件夹 “MySrc”, 在 “MySrc” 里创建proto文件auth.proto, 在桌面创建放转换后的文件的文件夹 “MyGen”, 则在终端 先cd 到桌面 1protoc --proto_path=MySrc --objc_out=MyGen MySrc/XXX.proto 执行命令后会发现在 “MyGen” 文件夹中出现 XXX.pbobjc.h / XXX.pbobjc.m, 这两个就是我们项目中需要的文件。 三.向项目集成protobuf将生成的Objective-C文件（上面例子的XXX.pbobjc.h和XXX.pbobjc.m）放到项目中，如果项目使用了ARC,要将.m（例子的XXX.pbobjc.m）的Complier Flags设为-fno-objc-arc。（protobuf基于性能原因没有使用ARC） 加入protobuf库，有两种方式 第一种是使用CocoaPods集成 使用CocoaPods集成，有一个现成的pod可以使用–Protobuf,可以pod search Protobuf搜索查看详情，pod内容为 1pod 'Protobuf' 第二种是把相关文件拖入项目中。 拖入相关文件到项目中，将objective-c文件夹下的所有的.h文件和.m文件（除了GPBProtocolBuffers.m）(GPB开头的那些文件)以及整个google文件夹add到项目中，如果项目中使用了ARC需要将以上所有.m文件的的Complier Flags设为-fno-objc-arc。缺点是操作麻烦点，如果用了ARC的话还要手动添加-fno-objc-arc（使用CocoaPods集成会自动添加）,记得添加User Header Search Paths为$(PROJECT_DIR)/项目名/后接文件地址 不然头文件会报错 完成，可以使用这个类进行操作了。","link":"/2020/08/14/protobuf-iOS%E4%BD%BF%E7%94%A8/"},{"title":"串","text":"","link":"/2019/09/11/%E4%B8%B2/"},{"title":"小程序flex布局","text":"尺寸单位rpx,规定屏幕宽为750rpx flex布局flex布局是小程序经常使用布局方式 开启方式: display:flex; (black-level形式存在) 或 display:inline-flex; (inline-level形式存在) 开启flex布局的元素叫flex container,其中直系子元素叫做flex items 属性flex-derection决定了main axis的方向 属性值: row | row-reverse | column | column-reverse justify-content决定了flex items在main axis上的对其方式 flex-start(默认值):与main start对齐 flex-end:与main-end对齐 center:居中对齐 space-between:items之间的距离相等,与main-start,main-end两端对齐 Space-evenly:items之间的距离相等,items与main-start,main-end之间的距离等于items之间的距离. Space-around:items之间的距离相等,与main-start,main-end之间的距离等于items之间的距离的一半 Align-items决定了在cross axis上的对其方式 stretcha(默认值):当flex-items在cross axis方向的size为auto时,会自动拉伸至填充flex container Flex-start:与cross start对齐 Flex-end:与cross end对齐 center: 居中对齐 Baseline:与基准下对齐 Flex-wrap决定了flex container是单行还是多行 nowrap(默认):单行 wrap:多行 Wrap-reverse:多行(对比wrap,cross start与cross end相反) flex-flow是flex-derection || flex-wrap的简写 比如flex-flow:column wrap等价于 Flex-derection:colunm Flex-warp:warp Align-content决定了多行flex items在cross axis上的对齐方式,用法与justify-content类似 stretch(默认值):与align-items的stretch类似 Flex-start:与cross start对齐 Flex-end:与cross end对齐 Center:居中对齐 Space-between:items之间的距离相等,与cross-start,cross-end两端对齐 Space-around:items之间的距离相等,与cross-start,cross-end之间的距离等于items之间的距离的一半 Space-evenly:items之间的距离相等,items与cross-start,cross-end之间的距离等于items之间的距离. order决定了flex items的排布顺序 可以设置任意整数(正负数/0),值越小就越排在前面 默认值为0 Align-self flex items可以通过align-self覆盖flex contaner设置的align-items auto(默认值):遵从flex container的align-items设置 Stretch/flex-start/flex-end/center/baseline Flex-grow决定了flex items如何扩展多余空间 可以设置任意非负数字(正数/0),默认值是0 当flex container在main axis方向上有剩余size时,flex-grow属性才有效 flex-shrink决定了flex items如何收缩 可以设置任意非负数字(正数/0),默认值是1 当flex itemx在main axis方向上超过了flex container的size,flex-shrink属性才有效 flex-basis用来设置flex items在main axis方向上的bese size auto(默认值): content:取决于内容本身的size 决定了flex items最终base size的因素,游戏那几从高到低 Max-width\\max-height\\min-width\\min-height Flex-basis Width\\height 内容本身的size flex是flex-grow flex-grow flex-shrink? || flex-basis的简写 默认值 0 1 auto none:0 0 auto","link":"/2020/04/22/%E5%B0%8F%E7%A8%8B%E5%BA%8Fflex%E5%B8%83%E5%B1%80/"},{"title":"微信小程序学习笔记","text":"一、小程序代码组成1.1 JSON配置123456789101112{ &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:{ &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; }} 注意点： 1.json的key必须包裹在一个双引号中； 2.json的值支持以下数据类型： ​ 数字：包含浮点数和整数 ​ 字符串：需要包裹在双引号中 ​ Bool值，true或者false ​ 数组：需要包裹在方括号中[] ​ 对象：需要包裹在大括号中{} ​ Null 3.json文件无法使用注释 1.2 WXML模板 1.数据绑定 12&lt;!--pages/wxml/index.wxml--&gt;&lt;text&gt;当前时间：{{time}}&lt;/text&gt; ​ 2.属性值的绑定(属性值必须被包裹在双引号中) 1&lt;text data-test=&quot;{{test}}&quot;&gt; hello world&lt;/text&gt; 语法内可进行简单的逻辑运算 123456三元运算&lt;!-- 根据 a 的值是否等于 10 在页面输出不同的内容 --&gt;&lt;text&gt;{{ a === 10? &quot;变量 a 等于10&quot;: &quot;变量 a 不等于10&quot;}}&lt;/text&gt;算数运算&lt;view&gt; {{a + b}} + {{c}} + d &lt;/view&gt; 4.条件逻辑 12345&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;&lt;view wx:if=&quot;{{length &gt; 5}}&quot;&gt; 1 &lt;/view&gt;&lt;view wx:elif=&quot;{{length &gt; 2}}&quot;&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 5.列表渲染 12345678&lt;view wx:for=&quot;{{array}}&quot;&gt; {{index}}: {{item.message}}&lt;/view&gt;&lt;!-- 使用 wx:for-item 指定数组当前元素的变量名，使用 wx:for-index 指定数组当前下标的变量名：--&gt;&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt; {{idx}}: {{itemName.message}}&lt;/view&gt; 6.wx:key的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 123456&lt;switch wx:for=&quot;{{objectArray}}&quot; wx:key=&quot;unique&quot; &gt; {{item.id}} &lt;/switch&gt;&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;&lt;switch wx:for=&quot;{{numberArray}}&quot; wx:key=&quot;*this&quot; &gt; {{item}} &lt;/switch&gt;&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add Number to the front &lt;/button&gt; 7.模板 12345678910111213141516&lt;!--item: { index: 0, msg: 'this is a template', time: '2016-06-18'}--&gt;&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt; &lt;text&gt; Time: {{time}} &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt; 8.引用 WXML 提供两种文件引用方式import和include。 import 可以在该文件中使用目标文件定义的 template，只会 import 目标文件中定义的 template，而不会 import 目标文件中 import 的 template，简言之就是 import 不具有递归的特性 include 可以将目标文件中除了 外的整个代码引入，相当于是拷贝到 include 位置 1.3 WXSS 样式 1.在WXSS中，引入了rpx（responsive pixel）尺寸单位,标准为750*1334rpx,标准和iphone6一样 2.引用 引用另一个样式文件：@import './test_0.wxss' 3.内联样式 1&lt;view style=&quot;color: red; font-size: 48rpx&quot;&gt;&lt;/view&gt; 4选择器 类型 选择器 样例 样例描述 类选择器 .class .intro 选择所有拥有 class=”intro” 的组件 id选择器 #id #firstname 选择拥有 id=”firstname” 的组件 元素选择器 element view checkbox 选择所有文档的 view 组件和所有的 checkbox 组 伪元素选择器 ::after view::after 在 view 组件后边插入内容 伪元素选择器 ::before view::before 在 view 组件前边插入内容 1.4JavaScript 脚本生命周期函数 参数属性 类型 描述 onLoad Function 生命周期函数–监听页面加载，触发时机早于onShow和onReady onReady Function 生命周期函数–监听页面初次渲染完成 onShow Function 生命周期函数–监听页面显示，触发事件早于onReady onHide Function 生命周期函数–监听页面隐藏 onUnload Function 生命周期函数–监听页面卸载 onPullDownRefresh Function 页面相关事件处理函数–监听用户下拉动作 onReachBottom Function 页面上拉触底事件的处理函数 onShareAppMessage Function 用户点击右上角转发 二、小程序界面2.1组件一个小程序页面可以分解成多个部分组成，组件就是小程序页面的基本组成单元。为了让开发者可以快速进行开发，小程序的宿主环境提供了一系列基础组件。 组件共有属性 属性名 类型 描述 其他说明 id String 组件的唯一标示 保持整个页面唯一 class String 组件的样式类 在对应的WXSS中定义的样式类 style String 组件的内联样式 可以通过数据绑定进行动态设置的内联样式 hidden Boolean 组件是否显示 所有组件默认显示 data-* Any 自定义属性 组件上触发的事件时，会发送给事件处理函数 bind / catch EventHandler 事件 绑定、捕获事件 微信官方组件https://developers.weixin.qq.com/miniprogram/dev/component/ 三方组件：https://youzan.github.io/vant-weapp/#/intro 2.2常见事件 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发 2.3page生命周期函数 三、API宿主环境提供了丰富的API，可以很方便调起微信提供的能力. 3.1路由跳转​ wx.switchTab(Object object) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 ​ wx.navigateTo(Object object)保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 3.2网络请求12345678910111213wx.request({ url: 'test.php', //仅为示例，并非真实的接口地址 data: { x: '', y: '' }, header: { 'content-type': 'application/json' // 默认值 }, success (res) { console.log(res.data) }}) 属性 类型 默认值 必填 说明 url string 是 开发者服务器接口地址 data string/object/ArrayBuffer 否 请求的参数 header Object 否 设置请求的 header，header 中不能设置 Referer。 content-type 默认为 application/json timeout number 否 超时时间，单位为毫秒 method string GET 否 HTTP 请求方法 dataType string json 否 返回的数据格式 responseType string text 否 响应的数据类型 enableCache boolean false 否 开启 cache success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 常用object.method 的合法值 值 说明 GET HTTP 请求 GET HEAD HTTP 请求 HEAD POST HTTP 请求 POST PUT HTTP 请求 PUT 3.3 数据缓存wx.setStorage(Object object) 将数据存储在本地缓存中指定的 key 中，所有数据存储上限为 10MB。 1234567891011wx.setStorage({ key:&quot;key&quot;, data:&quot;value&quot;})wx.getStorage({ key: 'key', success (res) { console.log(res.data) }}) wx.getStorage(Object object) 从本地缓存中异步获取指定 key 的内容 3.4 其他 更多api可以查看官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/ 四、云开发","link":"/2020/05/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"栈","text":"数据结构和算法动态可视化:https://visualgo.net/zh","link":"/2019/09/11/%E6%A0%88/"},{"title":"树","text":"","link":"/2019/09/16/%E6%A0%91/"},{"title":"线性表","text":"","link":"/2019/09/11/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"title":"读&lt;&lt;图解物联网&gt;&gt;","text":"感觉物联网现在越来越热门,智能家居/工业物联网应用越来越多,于是想全面的连接物联网基本知识结构,所以看了该书.感觉不错,本书从硬件到软件到物联云,系统了讲解了开发物联网应用需要的知识. 全书看下来,感觉当前还是处于物联网初期,感觉物联网应用的比较多的还是工业,智能家居也有不少的用户开始接受了,但是比较零散,很多没有形成系统,很多设备只是简单了添加联网模块,未给硬件添加智能化和自动化,不过自动驾驶应该是一项技术突破,设计到n多传感器和自动化驾驶.","link":"/2020/07/01/%E8%AF%BB-%E5%9B%BE%E8%A7%A3%E7%89%A9%E8%81%94%E7%BD%91/"},{"title":"队列","text":"","link":"/2019/09/11/%E9%98%9F%E5%88%97/"},{"title":"flutter学习笔记","text":"基本组件state生命周期initState：当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作;didChangeDependencies()：当State对象的依赖发生变化时会被调用；build()：此回调读者现在应该已经相当熟悉了，它主要是用于构建Widget子树的，会在如下场景被调用：在调用initState()之后。在调用didUpdateWidget()之后。在调用setState()之后。在调用didChangeDependencies()之后。在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后didUpdateWidget()：如果Widget.canUpdate返回true则会调用此回调deactivate()：当State对象从树中被移除时，会调用此回调。dispose()：当State对象从树中被永久移除时调用； GlobalKey:一种通用的获取State对象的方法1.给目标StatefulWidget添加GlobalKey//定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储static GlobalKey _globalKey= GlobalKey();…Scaffold( key: _globalKey , //设置key …)2.通过GlobalKey来获取State对象_globalKey.currentState.openDrawer() 文本Text、按钮、图片Image单选框Switch、复选框Checkbox输入框textField、表单Form输入框键盘类型1.text文本输入键盘2.multiline多行文本，需和maxLines配合使用(设为null或大于1)3.number数字；会弹出数字键盘4.phone优化后的电话号码输入键盘；会弹出数字键盘并显示“* #”5.datetime优化后的日期输入键盘；Android上会显示“: -”6.emailAddress优化后的电子邮件地址；会显示“@ .”7.url优化后的url输入键盘； 会显示“/ .” 进度指示器LinearProgressIndicator线性、条状的进度条 CircularProgressIndicator一个圆形进度条 布局类组件线性布局textdirection：表示子组件的排列顺序，对于row是从左向右，还是从右向左 mainAxisAlignment:MainAxisAlignment.start表示沿textDirection的初始方向对齐;而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。 Row横向 Colunm纵向排列子组件 flex(Row和Column都继承自Flex) 弹性布局Expandedconst Expanded({ int flex = 1, @required Widget child,})flex参数为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间 流式布局 wrap(子元素超出显示范围后会折行) spacing：主轴方向子widget的间距runSpacing：纵轴方向的间距 Flow 需要自己写布局配置 层叠布局 stack 子元素可层叠展示 positioned 与stack搭配使用时，根据Stack的四个角来确定子组件的位置 Align aligment属性相对父组件确定原点 Center 容器类组件Container一个组合类容器Container({ this.alignment, this.padding, //容器内补白，属于decoration的装饰范围 Color color, // 背景色 Decoration decoration, // 背景装饰 Decoration foregroundDecoration, //前景装饰 double width,//容器的宽度 double height, //容器的高度 BoxConstraints constraints, //容器大小的限制条件 this.margin,//容器外补白，不属于decoration的装饰范围 this.transform, //变换 this.child,}) PaddingConstrainedBox、SizedBox、UnconstrainedBox、AspectRatio尺寸限制装饰容器DecoratedBoxboxdecoration时decoration的子类BoxDecoration({ Color color, //颜色 DecorationImage image,//图片 BoxBorder border, //边框 BorderRadiusGeometry borderRadius, //圆角 List boxShadow, //阴影,可以指定多个 Gradient gradient, //渐变 BlendMode backgroundBlendMode, //背景混合模式 BoxShape shape = BoxShape.rectangle, //形状}) 变换Transform平移transform.translate旋转transform.rotate缩放transform.scale Scaffold是一个路由页的骨架 AppBar顶部导航栏 剪裁ClipClipOval子组件为正方形时剪裁为内贴圆形，为矩形时，剪裁为内贴椭圆ClipRRect将子组件剪裁为圆角矩形ClipRect剪裁子组件到实际占用的矩形大小（溢出部分剪裁） 滚动列表类组件ListViewListView.builder适合列表项比较多（或者无限）的情况，因为只有当子组件真正显示的时候才会被创建，也就说通过该构造函数创建的ListView是支持基于Sliver的懒加载模型的ListView.builder({ // ListView公共参数已省略 … @required IndexedWidgetBuilder itemBuilder, int itemCount, …}) ListView.separated分割组件生成器 class ListView3 extends StatelessWidget { @override Widget build(BuildContext context) { //下划线widget预定义以供复用。 Widget divider1=Divider(color: Colors.blue,); Widget divider2=Divider(color: Colors.green); return ListView.separated( itemCount: 100, //列表项构造器 itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(&quot;$index&quot;)); }, //分割器构造器 separatorBuilder: (BuildContext context, int index) { return index%2==0?divider1:divider2; }, ); }} GridView和listview类似，gridDelegate是抽象类，子类需要实现具体的布局算法 SliverGridDelegateWithFixedCrossAxisCount固定数量子元素 SliverGridDelegateWithMaxCrossAxisExtent固定最大长度 Scrollbar滚动条给可滚动组件添加滚动条，只需将Scrollbar作为可滚动组件的任意一个父级组件即可 SingleChildScrollView应在期望的内容不会超过屏幕太多时使用，这是因为SingleChildScrollView不支持基于Sliver的延迟实例化模型 CustomScrollView可以使用Sliver来自定义滚动模型（效果）的组件 ScrollController功能型组件事件处理动画效果自定义组件常用方式文件操作和网络请求与native混合开发https://github.com/alibaba-flutter/flutter-boot","link":"/2020/06/28/flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"swift学习笔记","text":"基础语法基础部分 var、let 类型注解 当你声明常量或者变量的时候可以加上类型注解（type annotation），说明常量或者变量中要存储的值的类型var welcome : String 变量常量命名 1.常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字2.使用保留关键字相同的名称命名，可以使用反引号（`）将关键字包围的方式，但不推荐 打印print print(_:separator:terminator:) separator分隔符terminator末尾终止符 注释 //单行注释/*多行注释*/ 不强制要求语句末尾添加分号； 数字类型推荐使用Int/Double，减少类型转换性能消耗 类型安全语言，自动类型推断 类型取别名typealias 布尔值true 和 false 元祖 1.元组把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型 可选类型String？ 强制解析！ 可选绑定 if let constantName = someOptional { statements} 隐式解析可选类型String! 错误处理 func canThrowAnError() throws { // 这个函数有可能抛出错误} 断言与先决条件assert 基本运算符 switch 1.默认每个case后不用写自己写break,2.可使用fallthrough实现贯穿效果3.必须保证能处理所有情况4.支持Character/string类型比较 字符串和字符集合控制流函数func pi() -&gt; Double{ return 3.14} 参数标签 func gotoWork(at time:string){ print(&apos;this time is \\(time)&apos;)} gotoWork(at:”08:00”) 可以使用下划线_省略参数标签 func sum(_ v1: Int,_ v2: Int) -&gt; Int{ v1+v2} 参数可以有默认值 func check(name: String = “nobody”,age: Int){ } 可变参数 一个函数最多只能有1个可变参数 输入输出参数inout 函数重载 闭包枚举类和结构体属性方法下标继承","link":"/2020/03/28/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"App Store Connect二进制文件无效","text":"使用了以下方法排查,最后还是提示”二进制文件无效”,也不能查看到原因,后来想到了会不会把具体原因发到邮箱了,后来在邮箱里看到了原因提示,这样就能精准定位了,不用一个个去排查了. 原来是前段时间要用到蓝牙,我把一个蓝牙工具类放进去了,因为暂时没用到忘记添加权限plist说明了,捣鼓了半天把下面的全部试了一遍,嗨…. 参考文章: 上传了新版本，收到信息 二进制文件无效 。但是在AppStoreConnect看不到被拒原因。 这是我收到的仅有的提示信息 二进制文件无效可能的原因: 一. 项目中使用了系统某些权限（相机，相册，麦克风等），但是在info.plist中没有添加 二. 使用私有API或IDFA 三. scheme设置 四. app图标修改相关 五. UIWebView等废弃API 一. 项目中使用了系统某些权限（相机，相册，麦克风等），但是在info.plist中没有添加 这个是我遇到的问题，代码使用权限，需要在info.plist做配置 权限都要弹框提示,隐私数据对应key值提示语必须说出指明用途,否则上线会被拒绝 参考链接1 这位帖主提醒我检测权限 参考链接2 这位贴主告诉我得配置提示语 左边为加了提示语后的正确权限请求框 二. 使用私有API或IDFA 1、 cd 到你的工程目录 2、使用全局搜索命令(注意最后要加一个点) grep -r lockcomplete . 1 参考链接1 提示可能原因和检测方式 参考链接2 检测私有方法 参考链接3 检测私有方法 三. scheme设置 Product —-&gt;Scheme—-&gt;editScheme，然后把最后两项都改为release 四. app图标修改相关 参考链接 五. UIWebView等废弃API 在项目中全局搜索 ———————————————— 版权声明：本文为CSDN博主「时光不染」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/hzhnzmyz/article/details/114931053","link":"/2022/07/04/App-Store-Connect%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E6%97%A0%E6%95%88/"},{"title":"OC与JS交互","text":"","link":"/2020/07/02/OC%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"},{"title":"Xib及自定义控件封装","text":"view的封装（自定义控件封装） 如果一个view内部的子控件比较多，一般会考虑自定义一个view，把它内部子控件的创建屏蔽起来，不让外界关心 外界可以传入对应的模型数据给view，view拿到模型数据后给内部的子控件设置对应的数据 封装控件的基本步骤 在initWithFrame:方法中添加子控件，提供便利构造方法 在layoutSubviews方法中设置子控件的frame（一定要调用super的layoutSubviews） 增加模型属性，在模型属性set方法中设置数据到子控件上Xib和storyboard对比 共同点： 都用来描述软件界面 都用Interface Builder工具来编辑 本质都是转换成代码去创建控件 不同点 Xib是轻量级的，用来描述局部的UI界面 Storyboard是重量级的，用来描述整个软件的多个界面，并且能展示多个界面之间的跳转关系Xib的加载 12345// 方法1NSArray *views = [[NSBundle mainBundle] loadNibNamed:@&quot;xib文件名&quot; owner:nil options:nil]// 方法2UINib *nib = [UINib nibWithNibName:@&quot;xib文件名&quot; bundle:nil];NSArray *views = [nib instantiateWithOwner:nil options:nil]; 使用xib自定义view的步骤 新建自定义控件类（如KZKShopView） Subclass of选择 UIView 新建Xib文件（文件名建议和View的类名一致，这样看起来比较直观） 修改Xib中View的类名（Custom Class） 封装xib的加载过程 12345678910// h头文件中@interface KZKShopViwe : View+ (instancetype)shopView;@end// m文件中@implementation KZKShopwView+ (instancetype)shopView{ return [[[NSBundle mainBundle] loadNidNamed:@&quot;KZKShopView&quot; owver:nil options:nil] lastobject];}@end 增加模型属性，在模型属性set方法中设置数据到子控件上注意点 一个控件有两种创建方式 通过代码创建 初始化时一定会调用initWithFrame:方法 通过xib\\storyboard创建 初始化时不会调用initWithFrame:方法，只会调用initWithCoder:方法 初始化完毕后会调用awakeFromNib方法 有时候希望在控件初始化时做一些初始化操作，比如添加子控件、设置基本属性 这时需要根据控件的创建方式，来选择在initWithFrame:、initWithCoder:、awakeFromNib的哪个方法中操作 参考 XIB自定义View的坑（https://juejin.cn/post/6844903636741390344）","link":"/2020/07/04/Xib%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"title":"iOS 预编译指令#if","text":"OC中的预编译指令有三种功能1：宏定义 2条件编译 3文件包含 1、宏定义 1-1定义格式： #define 标识符 字符串 1、 不含参数： #define TAG_VIEW 10086 2、 含有参数：#define MAX_INT(a,b) a+b 1-2宏定义的说明 1、宏名一般习惯用大写字母表示，以便与变量名相区别。但这并非规定，也可用小写字母。 2、 宏定义是用宏名代替一个字符串，只作简单置换，不作正确性检查，同时也不会做运算逻辑处理,同时在进行宏定义时，可以引用已定义的宏名，可以层层置换。在这里需要特别注意的是：当宏涉运算时，要根据情况来添加括号。 3、 ＃define 命令出现在程序中函数的外面，宏名的有效范围为定义命令之后到本文件结束。通常，＃define 命令写在文件开头，函数之前，作为文件一部分，在此文件范围内有效。 4、 可以用＃undef 命令终止宏定义的作用域。 5、宏定义是专门用于预处理命令的一个专用名词，它与定义变量的含义不同，只作字符替换，不分配内存空间。 特别提示： 1、省略号…和VA_ARGS的使用–关于省略号··· 代表的是个数可变的参数即可变参数，一般会与VAARGS__结合使用，VAARGS__表示保留名，将省略号省略的参数传递给宏。如下 // 例如我们最常见的形式 #ifdef DEBUG #define JRLog(…) NSLog(VA_ARGS) #else #define JRLog(…)// 如果编译经过在这里那么JRLog(···)无意义 #endif 2、条件编译 条件编译就是在编译之前预处理器根据预处理指令判断对应的条件，如果条件满足就将对应的代码编译进去，否则代码就根本不进入编译环节（相当于根本就没有这段代码）。 常用的条件编译函数： 1、#if 编译预处理中的条件命令, 相当于C语法中的if语句，如果if后判断为真则执行if后面的代码块 2、 #ifdef 判断某个宏是否被定义, 若已定义, 执行随后的语句-注意只会判断该宏是否定义，而不会具体判断语句的正确性 3、 #ifndef 与#ifdef相反, 判断某个宏是否未被定义 4、 #elif 若#if, #ifdef, #ifndef或前面的#elif条件不满足, 则执行#elif之后的语句, 相当于C语法中的else-if 6、 #else 与#if, #ifdef, #ifndef对应, 若这些条件不满足, 则执行#else之后的语句, 相当于C语法中的else 7、 #endif #if, #ifdef, #ifndef这些条件命令的结束标志. 8、#if 与 #ifdef 的区别：#if是判断后面的条件语句是否成立，#ifdef是判断某个宏是否被定义过。要区分开！ #ifdef MAX_F // 如果定义了宏MAX_F，则编译此处的代码 #else // 如果没有定义宏MAX_F，则编译此处的代码 #endif // 同样 #ifndef MAX_F // 如果没有定义宏MAX_F，则编译此处的代码 #elif MAX_INT // 如果定义了宏MAX_F,同时还定义了宏MAX_INT，则编译此处的代码 #else // 定义了宏MAX_F,但是没有定义宏MAX_INT，则编译此处的代码 #endif 另外在pch文件中，可以看到自带一个条件编译 #ifndef Header_h #define Header_h #endif 这种格式是为了防止该头文件被引用时发生重复引用。 条件编译的常用情况： 1：情况1： #ifdef _XXXX …程序段1… #else …程序段2… #endif 这表明如果标识符_XXXX已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。 例如： #define NUM …………. …………. …………. #ifdef NUM printf(“之前NUM有过定义啦！:) “); #else printf(“之前NUM没有过定义！:( “); #endif } 如果程序开头有#define NUM这行，即NUM有定义，碰到下面#ifdef NUM的时候，当然执行第一个printf。否则第二个printf将被执行。 我认为，用这种，可以很方便的开启/关闭整个程序的某项特定功能。 2:情况2： #ifndef _XXXX …程序段1… #else …程序段2… #endif 这里使用了#ifndef，表示的是if not def。当然是和#ifdef相反的状况（如果没有定义了标识符_XXXX，那么执行程序段1，否则执行程序段2）。例子就不举了。 3：情况3： #if 常量 …程序段1… #else …程序段2… #endif 这里表示，如果常量为真（非0，随便什么数字，只要不是0），就执行程序段1，否则执行程序段2。 我认为，这种方法可以将测试代码加进来。当需要开启测试的时候，只要将常量变1就好了。而不要测试的时候，只要将常量变0。 iOS常用的系统参数宏： // 判断是否是真机 #if TARGET_OS_IPHONE // 在这里一定不能使用#ifdef，因为TARGET_OS_IPHONE无论在真机还是模拟器情况下都存在只不过 模拟器时值为0 #else #endif // 判断是否是模拟器 #if TARGET_OS_SIMULATOR // 同上。”TARGET_IPHONE_SIMULATOR”已经废弃 #else #endif // 判断手机系统版本 #if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_9_0 #else #endif // 规定只能在ios系统下运行 #ifdef __IPHONE_OS_VERSION_MIN_REQUIRED ​ // 规定运行支持的最小版本 ​ #if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0 ​ #else ​ #endif #endif // 可以参照Availability.h 文件 文件路径 /Applications/Xcode8.1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include 不同Xcode版本路径略有差异 /** #define __IPHONE_2_0 20000 #define __IPHONE_2_1 20100 #define __IPHONE_2_2 20200 #define __IPHONE_3_0 30000 #define __IPHONE_3_1 30100 #define __IPHONE_3_2 30200 #define __IPHONE_4_0 40000 #define __IPHONE_4_1 40100 #define __IPHONE_4_2 40200 #define __IPHONE_4_3 40300 #define __IPHONE_5_0 50000 #define __IPHONE_5_1 50100 #define __IPHONE_6_0 60000 #define __IPHONE_6_1 60100 #define __IPHONE_7_0 70000 #define __IPHONE_7_1 70100 #define __IPHONE_8_0 80000 #define __IPHONE_8_1 80100 #define __IPHONE_8_2 80200 #define __IPHONE_8_3 80300 #define __IPHONE_8_4 80400 #define __IPHONE_9_0 90000 #define __IPHONE_9_1 90100 #define __IPHONE_9_2 90200 #define __IPHONE_9_3 90300 #define __IPHONE_10_0 100000 #define __IPHONE_10_1 100100 */ 3、文件包含 C语言下一般使用 #include, OC中一般使用 #import ,它们的区别是：在使用#include的时候要注意处理重复引用，#import大部分功能和#include是一样的,但是他处理了重复引用的问题,我们在引用文件的时候不用再去自己进行重复引用处理。OC中还有一个引用声明 @class主要是用于声明一个类,告诉编译器它后面的名字是一个类的名字,而这个类的定义实现是暂时不用知道的。一般来说,在interface中(.h文件)引用一个类,就用@class,它会把这个类作为一个类型来使用,而在实现这个interface的文件中,如果需要引用这个类的实体变量或者方法之类的,还是需要import这个在@class中声明的类。 ———————————————— 版权声明：本文为CSDN博主「yingBi2014」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/yingBi2014/article/details/79664466","link":"/2020/07/03/iOS-%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4-if-ifdef-elif-else-endif-import-define/"},{"title":"iOS多线程","text":"一 常见多线程方案 二 GCD2.1 基础术语 同步和异步主要影响:能不能开启新的线程 同步:在当前线程中执行任务,不具备开启新线程的能力 异步:在新线程中执行任务,具备开启新线程的能力 并发和串行的主要影响:任务的执行方式 并发:多个任务并发(同时)执行 串行:一个任务执行完毕后,在执行下一个任务 产生死锁:使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列 2.2常见使用 2.2.1任务+队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255/** * 同步执行 + 并发队列 * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。 */- (void)syncConCurrent{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncConcurrent---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;com.hs.queue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } });}输出结果:2021-02-19 17:36:25.088970+0800 GCD01[2847:134875] currentThread---&lt;NSThread: 0x6000035b0700&gt;{number = 1, name = main}2021-02-19 17:36:25.089089+0800 GCD01[2847:134875] syncConcurrent---begin2021-02-19 17:36:27.090291+0800 GCD01[2847:134875] 1---&lt;NSThread: 0x6000035b0700&gt;{number = 1, name = main}2021-02-19 17:36:29.090881+0800 GCD01[2847:134875] 1---&lt;NSThread: 0x6000035b0700&gt;{number = 1, name = main}2021-02-19 17:36:31.091210+0800 GCD01[2847:134875] 2---&lt;NSThread: 0x6000035b0700&gt;{number = 1, name = main}2021-02-19 17:36:33.092106+0800 GCD01[2847:134875] 2---&lt;NSThread: 0x6000035b0700&gt;{number = 1, name = main}2021-02-19 17:36:35.093407+0800 GCD01[2847:134875] 3---&lt;NSThread: 0x6000035b0700&gt;{number = 1, name = main}2021-02-19 17:36:37.093798+0800 GCD01[2847:134875] 3---&lt;NSThread: 0x6000035b0700&gt;{number = 1, name = main}/** * 异步执行 + 并发队列 * 特点：可以开启多个线程，任务交替（同时）执行。 */- (void)asyncConcurrent{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncConcurrent---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;com.hs.queue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); NSLog(@&quot;asyncConcurrent---end&quot;);}输出结果:2021-02-19 17:43:09.998795+0800 GCD01[2932:138556] currentThread---&lt;NSThread: 0x600000ffc740&gt;{number = 1, name = main}2021-02-19 17:43:09.998905+0800 GCD01[2932:138556] asyncConcurrent---begin2021-02-19 17:43:09.999027+0800 GCD01[2932:138556] asyncConcurrent---end2021-02-19 17:43:12.004240+0800 GCD01[2932:138746] 1---&lt;NSThread: 0x600000fda9c0&gt;{number = 8, name = (null)}2021-02-19 17:43:12.004239+0800 GCD01[2932:138757] 2---&lt;NSThread: 0x600000ff25c0&gt;{number = 7, name = (null)}2021-02-19 17:43:12.004241+0800 GCD01[2932:138747] 3---&lt;NSThread: 0x600000fbc8c0&gt;{number = 5, name = (null)}2021-02-19 17:43:14.004538+0800 GCD01[2932:138746] 1---&lt;NSThread: 0x600000fda9c0&gt;{number = 8, name = (null)}2021-02-19 17:43:14.004538+0800 GCD01[2932:138757] 2---&lt;NSThread: 0x600000ff25c0&gt;{number = 7, name = (null)}2021-02-19 17:43:14.004538+0800 GCD01[2932:138747] 3---&lt;NSThread: 0x600000fbc8c0&gt;{number = 5, name = (null)}/** * 同步执行 + 串行队列 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。 */- (void)syncSerial{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;com.hs.queue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); NSLog(@&quot;syncSerial---end&quot;);}输出结果:2021-02-19 17:46:09.812435+0800 GCD01[2986:140787] currentThread---&lt;NSThread: 0x6000027003c0&gt;{number = 1, name = main}2021-02-19 17:46:09.812540+0800 GCD01[2986:140787] syncSerial---begin2021-02-19 17:46:11.812918+0800 GCD01[2986:140787] 1---&lt;NSThread: 0x6000027003c0&gt;{number = 1, name = main}2021-02-19 17:46:13.813264+0800 GCD01[2986:140787] 1---&lt;NSThread: 0x6000027003c0&gt;{number = 1, name = main}2021-02-19 17:46:15.814544+0800 GCD01[2986:140787] 2---&lt;NSThread: 0x6000027003c0&gt;{number = 1, name = main}2021-02-19 17:46:17.814767+0800 GCD01[2986:140787] 2---&lt;NSThread: 0x6000027003c0&gt;{number = 1, name = main}2021-02-19 17:46:19.815968+0800 GCD01[2986:140787] 3---&lt;NSThread: 0x6000027003c0&gt;{number = 1, name = main}2021-02-19 17:46:21.816267+0800 GCD01[2986:140787] 3---&lt;NSThread: 0x6000027003c0&gt;{number = 1, name = main}2021-02-19 17:46:21.816439+0800 GCD01[2986:140787] syncSerial---end/** * 异步执行 + 串行队列 * 特点：会开启一条新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。 */- (void)asyncSerial{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;com.hs.queue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); NSLog(@&quot;asyncSerial---end&quot;);}输出结果:2021-02-19 17:48:48.440422+0800 GCD01[3023:142364] currentThread---&lt;NSThread: 0x6000021843c0&gt;{number = 1, name = main}2021-02-19 17:48:48.440607+0800 GCD01[3023:142364] asyncSerial---begin2021-02-19 17:48:48.440731+0800 GCD01[3023:142364] asyncSerial---end2021-02-19 17:48:50.445911+0800 GCD01[3023:142419] 1---&lt;NSThread: 0x600002199d00&gt;{number = 6, name = (null)}2021-02-19 17:48:52.451231+0800 GCD01[3023:142419] 1---&lt;NSThread: 0x600002199d00&gt;{number = 6, name = (null)}2021-02-19 17:48:54.455630+0800 GCD01[3023:142419] 2---&lt;NSThread: 0x600002199d00&gt;{number = 6, name = (null)}2021-02-19 17:48:56.455855+0800 GCD01[3023:142419] 2---&lt;NSThread: 0x600002199d00&gt;{number = 6, name = (null)}2021-02-19 17:48:58.461050+0800 GCD01[3023:142419] 3---&lt;NSThread: 0x600002199d00&gt;{number = 6, name = (null)}2021-02-19 17:49:00.463611+0800 GCD01[3023:142419] 3---&lt;NSThread: 0x600002199d00&gt;{number = 6, name = (null)}/*** 同步执行 + 主队列* 特点(主线程调用)：互相等待,卡住主线程,造成死锁*/- (void)syncMain{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncMain---begin&quot;); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_sync(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); NSLog(@&quot;syncMain---end&quot;);}输出结果:2021-02-19 17:51:57.239288+0800 GCD01[3047:144140] currentThread---&lt;NSThread: 0x600003c549c0&gt;{number = 1, name = main}2021-02-19 17:51:57.239399+0800 GCD01[3047:144140] syncMain---begin(lldb) /** * 异步执行 + 主队列 * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务 */- (void)asyncMain{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncMain---begin&quot;); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); NSLog(@&quot;asyncMain---end&quot;);}输出结果:2021-02-19 17:57:06.334474+0800 GCD01[3100:147296] currentThread---&lt;NSThread: 0x6000021f4080&gt;{number = 1, name = main}2021-02-19 17:57:06.334603+0800 GCD01[3100:147296] asyncMain---begin2021-02-19 17:57:06.334717+0800 GCD01[3100:147296] asyncMain---end2021-02-19 17:57:08.351357+0800 GCD01[3100:147296] 1---&lt;NSThread: 0x6000021f4080&gt;{number = 1, name = main}2021-02-19 17:57:10.351767+0800 GCD01[3100:147296] 1---&lt;NSThread: 0x6000021f4080&gt;{number = 1, name = main}2021-02-19 17:57:12.352891+0800 GCD01[3100:147296] 2---&lt;NSThread: 0x6000021f4080&gt;{number = 1, name = main}2021-02-19 17:57:14.353229+0800 GCD01[3100:147296] 2---&lt;NSThread: 0x6000021f4080&gt;{number = 1, name = main}2021-02-19 17:57:16.354593+0800 GCD01[3100:147296] 3---&lt;NSThread: 0x6000021f4080&gt;{number = 1, name = main}2021-02-19 17:57:18.354813+0800 GCD01[3100:147296] 3---&lt;NSThread: 0x6000021f4080&gt;{number = 1, name = main} 2.2.2**队列组dispatch_group** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 队列组 dispatch_group_notify *当所有任务都执行完成之后，才执行dispatch_group_notify block 中的任务 */- (void)qpc_dispatchgroup{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;myqueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_group_async(group, queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); NSLog(@&quot;group---end&quot;);}输出结果:2021-02-19 18:02:46.858071+0800 GCD01[3146:150155] currentThread---&lt;NSThread: 0x6000037681c0&gt;{number = 1, name = main}2021-02-19 18:02:46.858216+0800 GCD01[3146:150155] group---begin2021-02-19 18:02:46.858329+0800 GCD01[3146:150155] group---end2021-02-19 18:02:48.862878+0800 GCD01[3146:150280] 1---&lt;NSThread: 0x60000372d6c0&gt;{number = 7, name = (null)}2021-02-19 18:02:48.862876+0800 GCD01[3146:150281] 2---&lt;NSThread: 0x60000372c640&gt;{number = 3, name = (null)}2021-02-19 18:02:50.864822+0800 GCD01[3146:150280] 1---&lt;NSThread: 0x60000372d6c0&gt;{number = 7, name = (null)}2021-02-19 18:02:50.864823+0800 GCD01[3146:150281] 2---&lt;NSThread: 0x60000372c640&gt;{number = 3, name = (null)}2021-02-19 18:02:52.865242+0800 GCD01[3146:150155] 3---&lt;NSThread: 0x6000037681c0&gt;{number = 1, name = main}2021-02-19 18:02:54.865686+0800 GCD01[3146:150155] 3---&lt;NSThread: 0x6000037681c0&gt;{number = 1, name = main}/** * 队列组 dispatch_group_wait *当所有任务执行完成之后，才执行 dispatch_group_wait 之后的操作,会阻塞当前线程 */- (void)groupWait{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;myqueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_group_async(group, queue, ^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;group---end&quot;);}输出结果:2021-02-19 18:09:41.868091+0800 GCD01[3187:153758] currentThread---&lt;NSThread: 0x6000030e4140&gt;{number = 1, name = main}2021-02-19 18:09:41.868220+0800 GCD01[3187:153758] group---begin2021-02-19 18:09:43.873508+0800 GCD01[3187:153883] 2---&lt;NSThread: 0x6000030de980&gt;{number = 6, name = (null)}2021-02-19 18:09:43.873508+0800 GCD01[3187:153881] 1---&lt;NSThread: 0x6000030d7a80&gt;{number = 7, name = (null)}2021-02-19 18:09:45.875594+0800 GCD01[3187:153881] 1---&lt;NSThread: 0x6000030d7a80&gt;{number = 7, name = (null)}2021-02-19 18:09:45.875594+0800 GCD01[3187:153883] 2---&lt;NSThread: 0x6000030de980&gt;{number = 6, name = (null)}2021-02-19 18:09:45.875811+0800 GCD01[3187:153758] group---end/** * 队列组 dispatch_group_enter、dispatch_group_leave *当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的dispatch_group_enter、dispatch_group_leave组合，其实等同于dispatch_group_async */- (void)groupEnterAndLeave{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;group---begin&quot;); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_enter(group); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } dispatch_group_leave(group); }); dispatch_group_enter(group); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } dispatch_group_leave(group); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 等前面的异步操作都执行完毕后，回到主线程. for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); NSLog(@&quot;group---end&quot;);}输出结果:2021-02-19 18:17:13.875926+0800 GCD01[3252:157677] currentThread---&lt;NSThread: 0x600000e807c0&gt;{number = 1, name = main}2021-02-19 18:17:13.876043+0800 GCD01[3252:157677] group---begin2021-02-19 18:17:13.876179+0800 GCD01[3252:157677] group---end2021-02-19 18:17:15.876440+0800 GCD01[3252:157767] 2---&lt;NSThread: 0x600000ec5740&gt;{number = 7, name = (null)}2021-02-19 18:17:15.876486+0800 GCD01[3252:157765] 1---&lt;NSThread: 0x600000ec8600&gt;{number = 8, name = (null)}2021-02-19 18:17:17.881362+0800 GCD01[3252:157767] 2---&lt;NSThread: 0x600000ec5740&gt;{number = 7, name = (null)}2021-02-19 18:17:17.881362+0800 GCD01[3252:157765] 1---&lt;NSThread: 0x600000ec8600&gt;{number = 8, name = (null)}2021-02-19 18:17:19.882660+0800 GCD01[3252:157677] 3---&lt;NSThread: 0x600000e807c0&gt;{number = 1, name = main}2021-02-19 18:17:21.883995+0800 GCD01[3252:157677] 3---&lt;NSThread: 0x600000e807c0&gt;{number = 1, name = main} 2.2.3**dispatch_barrier_async 栅栏方法** 12345678910111213141516171819202122232425262728293031323334353637383940/** * 栅栏方法 dispatch_barrier_async * 执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作 */- (void)barrier{ dispatch_queue_t queue = dispatch_queue_create(&quot;com.hs.dome&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); } }); dispatch_barrier_async(queue, ^{ for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;barrier---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i &lt; 2; ++i) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;4---%@&quot;,[NSThread currentThread]); } });} 2.2.4**dispatch_semaphore 信号量** 123456789101112131415161718192021/** * semaphore 线程同步 * 将异步执行任务转换为同步执行任务 */- (void)semaphoreSync{ NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); NSLog(@&quot;semaphore---begin&quot;); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); __block int number = 0; dispatch_async(queue, ^{ [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); number = 100; dispatch_semaphore_signal(semaphore); }); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;semaphore---end,number = %d&quot;,number);} 三 NSOperation3.1.1 NSOperation、NSOperationQueue 使用步骤 12345678910111213141516171819202122232425262728293031/** * 使用 addOperationWithBlock: 将操作加入到操作队列中 * 将操作加入到操作队列后能够开启新线程，进行并发执行 */- (void)addOperationWithBlockToQueue{ NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); } }]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); } }]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); } }]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); } }];} 3.1.2 控制串行执行、并发执行 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数 maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。 maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。 maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制 12345678910111213141516171819202122232425262728293031/** * 设置 MaxConcurrentOperationCount（最大并发操作数） */- (void)addOperationWithBlockToQueue{ NSOperationQueue *queue = [[NSOperationQueue alloc] init]; queue.maxConcurrentOperationCount = 1;//串行执行 [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); } }]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); } }]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); } }]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); } }];} 总结: 当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。 3.1.3 addDependency操作依赖 1234567891011121314151617181920212223- (void)addDependency{ NSOperationQueue *queue = [[NSOperationQueue alloc] init]; NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); } }]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); } }]; [op2 addDependency:op1];// 让op2 依赖于 op1，则先执行op1，在执行op2 [queue addOperation:op1]; [queue addOperation:op2];}打印结果:2021-02-20 15:21:40.251808+0800 GCD01[4133:192904] 1---&lt;NSThread: 0x600003adad80&gt;{number = 5, name = (null)}2021-02-20 15:21:42.252554+0800 GCD01[4133:192904] 1---&lt;NSThread: 0x600003adad80&gt;{number = 5, name = (null)}2021-02-20 15:21:44.257346+0800 GCD01[4133:192903] 2---&lt;NSThread: 0x600003ad29c0&gt;{number = 7, name = (null)}2021-02-20 15:21:46.257638+0800 GCD01[4133:192903] 2---&lt;NSThread: 0x600003ad29c0&gt;{number = 7, name = (null)} 3.1.4 NSOperation 优先级 12345678// 优先级的取值typedef NS_ENUM(NSInteger, NSOperationQueuePriority) { NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8}; 设置优先级后并没有达到想要的效果,该属性还待解答. 1234567891011121314151617181920212223- (void)addDependency_queuePriority{ NSOperationQueue *queue = [[NSOperationQueue alloc] init]; NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; NSInvocationOperation *op3 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task3) object:nil]; NSInvocationOperation *op4 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task4) object:nil]; op4.queuePriority = NSOperationQueuePriorityVeryHigh; op1.queuePriority = NSOperationQueuePriorityLow; [queue addOperation:op1]; [queue addOperation:op2]; [queue addOperation:op3]; [queue addOperation:op4];}打印结果:2021-02-20 15:48:48.168577+0800 GCD01[4346:208620] 4---&lt;NSThread: 0x6000004729c0&gt;{number = 4, name = (null)}2021-02-20 15:48:48.168580+0800 GCD01[4346:208625] 1---&lt;NSThread: 0x600000466000&gt;{number = 3, name = (null)}2021-02-20 15:48:48.168581+0800 GCD01[4346:208622] 2---&lt;NSThread: 0x600000457a40&gt;{number = 5, name = (null)}2021-02-20 15:48:48.168577+0800 GCD01[4346:208626] 3---&lt;NSThread: 0x600000465880&gt;{number = 8, name = (null)}2021-02-20 15:48:50.173404+0800 GCD01[4346:208622] 2---&lt;NSThread: 0x600000457a40&gt;{number = 5, name = (null)}2021-02-20 15:48:50.173404+0800 GCD01[4346:208626] 3---&lt;NSThread: 0x600000465880&gt;{number = 8, name = (null)}2021-02-20 15:48:50.173404+0800 GCD01[4346:208625] 1---&lt;NSThread: 0x600000466000&gt;{number = 3, name = (null)}2021-02-20 15:48:50.173404+0800 GCD01[4346:208620] 4---&lt;NSThread: 0x6000004729c0&gt;{number = 4, name = (null)} 3.1.4 NSOperation线程间通信 12345678910111213141516171819/** * 线程间通信 */- (void)communication{ NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); } //返回主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { [NSThread sleepForTimeInterval:2]; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); } }]; }];} 四 多线程安全隐患-线程同步常见的线程同步技术:加锁 iOS常见加锁方案 OSSpinLock os_unfair_lock pthread_mutex dispatch_semaphore dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSRecursiveLock NSCondition NSConditionLock @synchronized 4.1 OSSpinLock OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源 目前已经不再安全，可能会出现优先级反转问题 如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁 需要导入头文件#import &lt;libkern/OSAtomic.h&gt; 4.2 os_unfair_lock os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等 需要导入头文件#import &lt;os/lock.h&gt; 4.3 pthread_mutex (normal) mutex叫做”互斥锁”，等待锁的线程会处于休眠状态 需要导入头文件#import &lt;pthread.h&gt; 4.4 pthread_mutex (recursive) 递归锁 4.5 pthread_mutex (condition) 条件 4.6 NSLock/NSRecursiveLock NSLock是对mutex普通锁的封装 NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致 4.7 NSCondition NSCondition是对mutex和cond的封装 4.8 NSConditionLock NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值 4.9 dispatch_semaphore semaphore叫做”信号量” 信号量的初始值，可以用来控制线程并发访问的最大数量 信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步 4.10 GCD串行队列 4.11 @synchronized @synchronized是对mutex递归锁的封装 @synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作 4.2 线程同步性能比较 性能从高到低排序 os_unfair_lock OSSpinLock dispatch_semaphore pthread_mutex dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSCondition pthread_mutex(recursive) NSRecursiveLock NSConditionLock @synchronized 五 读写方案 (多读单写) 同一时间，只能有1个线程进行写的操作 同一时间，允许多个线程进行读的操作 同一时间，不允许既有写的操作，又有读的操作 现有解决方案: pthread_rwlock：读写锁 dispatch_barrier_async：异步栅栏调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485- (void)viewDidLoad { [super viewDidLoad]; pthread_rwlock_init(&amp;_lock, NULL); dispatch_queue_t queue = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 10; i++) { dispatch_async(queue, ^{ [self read]; }); dispatch_async(queue, ^{ [self write]; }); }}- (void)read{ pthread_rwlock_rdlock(&amp;_lock); sleep(1); NSLog(@&quot;%s&quot;,__func__); pthread_rwlock_unlock(&amp;_lock);}- (void)write{ pthread_rwlock_wrlock(&amp;_lock); sleep(1); NSLog(@&quot;%s&quot;,__func__); pthread_rwlock_unlock(&amp;_lock);}// pthread_rwlock_destroy 是pthread锁，要销毁- (void)dealloc{ pthread_rwlock_destroy(&amp;_lock);}打印结果:2021-02-20 16:31:56.110128+0800 GCD01[4628:232022] -[ViewController read]2021-02-20 16:31:56.110128+0800 GCD01[4628:232025] -[ViewController read]2021-02-20 16:31:57.115415+0800 GCD01[4628:232023] -[ViewController write]2021-02-20 16:31:58.117225+0800 GCD01[4628:232024] -[ViewController write]2021-02-20 16:31:59.119190+0800 GCD01[4628:232026] -[ViewController read]2021-02-20 16:32:00.121009+0800 GCD01[4628:232028] -[ViewController write]2021-02-20 16:32:01.123432+0800 GCD01[4628:232030] -[ViewController read]2021-02-20 16:32:02.127358+0800 GCD01[4628:232031] -[ViewController write]2021-02-20 16:32:03.130017+0800 GCD01[4628:232032] -[ViewController read]2021-02-20 16:32:04.133641+0800 GCD01[4628:232033] -[ViewController write]2021-02-20 16:32:05.134574+0800 GCD01[4628:232034] -[ViewController read]2021-02-20 16:32:06.136287+0800 GCD01[4628:232035] -[ViewController write]2021-02-20 16:32:07.139924+0800 GCD01[4628:232036] -[ViewController read]2021-02-20 16:32:08.144879+0800 GCD01[4628:232037] -[ViewController write]2021-02-20 16:32:09.150167+0800 GCD01[4628:232038] -[ViewController read]2021-02-20 16:32:10.153798+0800 GCD01[4628:232039] -[ViewController write]2021-02-20 16:32:11.158837+0800 GCD01[4628:232040] -[ViewController read]2021-02-20 16:32:12.161323+0800 GCD01[4628:232041] -[ViewController write]2021-02-20 16:32:13.165552+0800 GCD01[4628:232042] -[ViewController read]2021-02-20 16:32:14.169961+0800 GCD01[4628:232043] -[ViewController write]- (void)viewDidLoad { [super viewDidLoad]; self.queue = dispatch_queue_create(&quot;rw_queue&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 10; i++) { dispatch_async(_queue, ^{ [self read]; }); dispatch_async(_queue, ^{ [self read]; }); dispatch_async(_queue, ^{ [self read]; }); dispatch_barrier_sync(self.queue, ^{ [self write]; }); }}- (void)read{ sleep(1); NSLog(@&quot;%s&quot;,__func__);}- (void)write{ sleep(1); NSLog(@&quot;%s&quot;,__func__);}","link":"/2020/07/02/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"iOS手机分辨率","text":"所有设备型号分辨率汇总： https://gist.github.com/adamawolf/3048717","link":"/2020/07/04/iOS%E6%89%8B%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87/"},{"title":"iOS给iot设备配网","text":"参考: 单播、组播、广播差别： https://www.cnblogs.com/wzjhoutai/p/6917477.html TCP/IP详解 卷1：协议:http://www.52im.net/topic-tcpipvol1.html 小端字节序与大端字节序 高位字节、低位字节","link":"/2022/07/01/iOS%E7%BB%99iot%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%91/"},{"title":"浅析ios中static和const的使用","text":"一、static修饰局部变量： 1、让局部变量只初始化一次 2、局部变量在程序中只生成一份内存 3、延长局部变量的生命周期,程序结束才会销毁。 修饰全局变量： 只能在本文件中访问,作用域仅限于当前文件 二、const被const修饰的变量是只读的，不可以修改 开发中经常用到static和const一起使用的情况,如定义一个只能在当前文件访问的全局常量 static 类型 const 常量名 ＝ 初始化值 例如：static NSString * const test = @”abc”; 作者：GoodProspect链接：https://www.jianshu.com/p/1a6fda82192b来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2020/07/04/%E6%B5%85%E6%9E%90ios%E4%B8%ADstatic%E5%92%8Cconst%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"web自动打包部署-jenkins","text":"传统的开发模式在传统的开发模式中，开发的整个过程是按部就班就行： 但是这种模式存在很大的弊端： 工作的不协调：开发人员在开发阶段，测试和运维人员其实是处于等待的状态。等到测试阶段，开发人员等待测试反馈 bug，也会处于等待状态线上 bug 的隐患：项目准备交付时，突然出现了 bug，所有人员需要加班、等待问题的处理 DevOps开发模式DevOps 是Development 和 Operations 两个词的结合，将开发和运维结合起来的模式： 持续集成和持续交付伴随着 DevOps 一起出现的两个词就是持续集成和持续交付(部署)： CI 是 Continuous Integration（持续集成）CD 是两种翻译：Continuous Delivery（持续交付）或 Continuous Deployment（持续部署） 持续集成 CI： 开发人员编写代码上传到代码仓库，让持续集成的服务器立马对代码进行测试构建，对其进行测试，如果结果有问题直接反馈开发人员. 不过这个都处理完结果是没有进行部署的，所有还有一个概念是持续交付 持续交付和持续部署 CD 把项目交给项目经理，项目经理对其进行部署，可能是自动化部署也可能是手动化部署在持续集成基础上会再进行一些测试，测试没有问题会打一个 release 版本 Web自动化部署流程 搭建服务器环境 请提前准备一台云服务器,阿里云或者腾讯云都可以,没有也可以考虑本地搭建服务器环境 ngnix部署web项目web部署需要用到nginx 安装nginx 12$ dnf install nginx 启动 nginx 1234$ systemctl start nginx$ systemctl status nginx$ systemctl enable nginx$ systemctl restart nginx 配置nginx访问你打包的文件 通过 Linux 命令创建文件夹和文件，并把你的web项目上传到你创建的文件夹下 12$ mkdir /root/test$ cd /root/test 配置 nginx 访问目录,修改两处 1/etc/nginx/nginx.conf 12345678910# user nginx;user root;server { location / { root /root/test; index index.html; }} Jenkins安装与配置安装 Java 环境Jenkins 本身是依赖 Java 的，所以我们需要先安装 Java 环境 12$ dnf search java$ dnf install java-17-openjdk 安装 Jenkins因为 Jenkins 本身是没有在 dnf 的软件仓库包中的，所以我们需要连接 Jenkins 仓库 wget 是 Linux 中下载文件的一个工具，-O 表示输出到某个文件夹并且命名为什么文件 rpm：全称为 The RPM Package Manage，是 Linux 下一个软件包管理器 123456$ wget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo# 导入GPG密钥以确保您的软件合法$ rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key# 或者$ rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key 编辑 /etc/yum.repos.d/jenkins.repo文件 通过 vim 编辑 $ vim /etc/yum.repos.d/jenkins.repo 1234[jenkins]name=Jenkins-stablebaseurl=http://pkg.jenkins.io/redhatgpgcheck=1 安装 Jenkins 1$ dnf install jenkins # --nogpgcheck(可以不加) 启动 Jenkins 的服务 1234$ systemctl start jenkins # 手动启动 Jenkins$ systemctl status jenkins$ systemctl enable jenkins # 开机自启动 Jenkins$ systemctl restart jenkins # 重启 Jenkins Jenkins 默认使用 8080 端口提供服务，所以需要已加入到esc安全组中： 配置Jenkins现在可以打开服务器：8080进入如下 获取输入管理员密码,远程终端输入： 1cat /var/lib/jenkins/secrets/initialAdminPassword 插件安装请选择推荐插件 插件正在安装中，请耐心等待 插件安装完成以后将会创建管理员账户，如下图所示 新建Jenkins 任务 选择Jenkins 任务配置 因为需要使用到git，需要系统安装git 1$ dnf install git 构建触发器这里的触发器规则是这样的：定时字符串从左往右分别是：分 时 日 月 周 1234567891011121314151617# 每半小时构建一次OR每半小时检查一次远程代码分支，有更新则构建H/30 * * * *# 每两小时构建一次OR每两小时检查一次远程代码分支，有更新则构建H H/2 * * *# 每天凌晨两点定时构建H 2 * * *# 每月15号执行构建H H 15 * *# 工作日，上午9点整执行H 9 * * 1-5# 每周1、3、5，从8:30开始，截止19:30，每4小时30分构建一次H/30 8-20/4 * * 1,3,5 构建环境node 我们需要搭建 Node 的环境 第一步：配置 Node 的环境 第二步：安装 Node 的插件 第一步：安装 Node 的插件 第二步：安装指定的 Node 版本 node环境装好后，选择shell脚本完成自动打包部署 123456789101112pwdnode -vnpm -vnpm install npm run buildpwdecho '构建成功'ls# 删除/root/test文件夹里所有的内容rm -rf /root/test/* cp -rf ./dist/* /root/test/ 正常情况，jenkins只能控制当前自己的文件夹(工作空间)，没有权限进入其他文件夹，这时如果需要进入其他的目标文件夹 解决办法: 方案1:修改jenkins执行时使用的用户组，修改为root 修改文件的路径: /etc/sysconfig/jenkins 之后重启一下jenkins; 方案2: sudo usermod -a -G root jenkins 将jenkins添加到root组中 方案3: chown -R jenkins /root/项目目录 给jenkins目录权限 (采用此方案搞定) 至此一个自动化任务就完成了！","link":"/2023/03/22/web%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2-jenkins/"},{"title":"&lt;&lt;老实人启蒙&gt;&gt;笔记","text":"豆瓣书评: https://book.douban.com/subject/1094864/","link":"/2024/11/07/%E8%80%81%E5%AE%9E%E4%BA%BA%E5%90%AF%E8%92%99-%E7%AC%94%E8%AE%B0/"},{"title":"&lt;财富自由之路&gt;笔记","text":"1、用正确的方法做正确的事情，你一定会变得更好。若长期持续使用正确的方法做正确的事情，你的未来一定会很伟大！ 2、一切有意义的成长过程都符合“复利曲线”，包括个人成长。 3、所谓“个人财富自由”，是指某个人再也不用为了满足生活必需而出售自己的时间。 4、最少必要知识（MAKE: Minimal Actionable Knowledge and Experience）：当需要获得某项技能的时候，一定要想办法在最短的时间里弄清楚都有哪些最少必要知识，然后迅速掌握他们。在那一瞬间，任何人都完成了“快速入门”——屡试不爽。 例如：PPT设计的最少必要知识就是两个关键词，简洁+留白 5、学习能力也好，执行力也罢，核心只有一个：在刚开始的时候，平静地接受自己的笨拙。 6、在做每件事的时候，判断工作结果和工作质量的好坏和高低，有两个标准：是否对得起拿到手的薪水？是否对得起自己付出的时间和精力。把自己变成一个“给自己打工的人”。 7、你的产品必须满足消费者的刚需，是消费者心里真正以为的刚需。 8、个人商业模式的基本分类： 第一种：一份时间出售1次 如何优化：想办法提高单位时间售价（方法是接受更高程度的教育）；想办法提高时间销售数量（把自己变成一个“给自己打工的人”） 第二种：同一份时间出售很多次（训练自己的创造能力和创新能力） 第三种：购买他人的时间再卖出去 9、时间投资到自己的成长上最划算，时间要用在升级自己的操作系统。 为了不断升级自己的操作系统，最需要掌握的能力是元认知能力。所谓“元认知”，是指“认知的认知”。当你思考的时候，你能意识到自己在思考，进一步能意识到自己在思考什么，再进一步能判断自己的思考方式和思考结果是否正确，更进一步能纠正自己错误的思考方式或者结果。元认知能力几乎是一切学习与进步的最底层和最根本的能力。 10、为了进化，我们要用实验和践行去检验我们的价值观和方法论， 把好的留下继续打磨，把不合适的去掉。 11、你所拥有的最宝贵的财富是注意力。注意力是你唯一可以随意调用且能有所产出的资源。 12、注意力&gt;时间&gt;金钱。若能用时间减少注意力的消耗，那一定不要去节省那个时间。 例如：李笑来花时间和老婆讲清道理，避免吵架，避免性不好，减少注意力不集中的情况。 13、无论如何，要把一切可能的注意力都放到自己的成长上去。不应该把注意力放在别人的“错”和“不好”上，若有空闲的注意力，不如关注别人哪里做得好，以便我吸收经验，获得成长。我们是活在未来的人，即使要比较，也要比较未来，而不是当下。 一个人所要自信的对象，应该是未来的自己，而不是现在的自己，更不是过去的自己。 14、人生3大坑，消耗注意力的同时让你毫无产出：第一是“莫名其妙凑热闹”，第二是“心急火燎地随大流”，第三是“为别人操碎了心”。 15、提高注意力使用效率的方法是坐享/打坐/禅修。 16、追求100%的安全感，肯定会把自己困在永恒的当下。我们必须放弃一部分安全感，才能长期、深入地观察和思考。（注意是一部分，不是100%地放弃，要提高自己的思考质量） 17、成为一个活在未来的人。如何做到活在未来？你现在对未来有一个预测，那个预测需要经过一段时间才能得到结果，你现在已经笃信你得到预测是正确的（即使是错误的，你已经放弃一部分安全感了，所以也不要太在意），你提前按照那个预测的结果去行动、选择、思考。时间自顾自地流失，而你终将走到那个结果出现的时刻。最终的事实证明，你的预测是正确的。 18、活在未来最朴素的方法就是“用正确的方法做正确的事”。做对的事远比把事情做对重要得多。 例如：自己首先得是个贵人，才能遇到贵人，甚至更多贵人。（乐观的、优秀的、能帮助别人进步的、不耻于求助的人……） 19、听大多数人的话，参考少数人的意见，最终自己做决定。“听大多数人的话”不是按照他们说的做，是听听他们怎么说，琢磨他们怎么想。不要追求别人的认可，“证明自己的正确”也不是学习的目标和任务，不要有表现型人格（在意当下表现），要拥有进取型人格（在意自己未来的表现）。 20、所谓“投资”，无非是用现在的资源换取未来的资源。这个概念放在财富管理、人际交往和学习成长等方面都是一样的。（若你能善待、宽容你的世界，你的世界大抵可以给你足够的善待和宽容；若你和身边的牛人多交流，你也有机会成为牛人，近朱者赤近墨者黑。） 21、抱怨，只是无能和无奈的表现而已。不抱怨，要基于自己的能力和韧性。能解决就去解决（能力），不能解决的就去承受（坚韧）。 22、真正的刚需是一切驱动力的源头。（如果有争做第一，做到极致的想法，那么就容易有持续的驱动力）在众多正确的刚需里，最关键最核心的是耐心。 23、从平庸走向卓越的最佳策略是多维度打造竞争力。处处平庸肯定不行，不求处处突出，但起码要在一个甚至多个维度上处于相当优异的位置，这样才能让多维度的意义以几何级数增长。（多维度低分相乘得到高分） 24、你如何变得更加值钱？成为一个真正有用的人，一个周围世界很需要你的人。 25、当遇到难以解决的问题，要把注意力从问题本身移开，因为解决方案肯定在别处。 26、无论做什么事情，在开始之前，都要想尽办法为这件事情赋予极其重大的意义，甚至多重重大的意义。 27、若我们生命中真的有最宝贵的东西，那只能是“希望”。所谓希望，就是一个人相信自己的明天会因为今天的努力变得更好。明天之所以能变好，是因为今天用正确的方式做了正确的事情。明天是否会变得更好，和今天的笨拙所带来的不适感甚至自卑感都没有关系。 28、成长就是想到之后做到，没有什么比“践行”更为重要了。 29、你的投资依据必须靠且仅靠自己的深入思考得到。“冒险”常常是他人对冒险者的理解，而不是所谓“冒险”成功的人的行动。看的人觉得那是冒险，做的人则是在深入思考后不得不做——思考越深入的人，越倾向于坚定地遵循思考结果。 30、“先发”可能是优势，也可能是劣势，有些时候，可能恰恰因为出现得太早了，才没能熬到明天。所以，是不是“早”根本不重要，关键在于是不是“对”。 31、关注周期，以及多个周期背后显现出来的真正趋势，汇给你一个全新且更为可靠的世界和视界。 32、真正的趋势，必须经过1个以上的周期才会显现。 33、最安全的投资策略是每天进步一点点。放在投资财富上来讲，就是定投。但定投要成功，前提是在开始之前，你要通过深入的研究得到了相当确定的结论：这是一家成长性极强的公司。所有的投资“功课”都是在投资之前完成的。“功课”是给自己做的。 34、锤炼自己的价值观就等同于提高选择的质量。再进一步，做出选择的更深层方法论是：添加必要的条件。（抓住主要矛盾，尽量“只考虑且不遗漏那些最为必要的条件”）。 例如：铁岭告诉李笑来一个创业方向的选择原则，即刚需、大市场、高频。 35、成长率：天天琢磨如何保持“成长率”的创业者才是真正的佼佼者。在风险投资者眼里，“成长率”是最重要的。（个人成长率） 36、对不同的人来说，“长期”的长度区别很可能非常大。每个人都可以通过提高能力来缩短“长期”的长度。对能使用正确策略的人来说，“长期”更短。对有能力在投资之外赚钱的人，“长期”更短。 你越弱，所谓的长期越长 37、所谓“融会贯通”，本质上就是在那些“清晰、准确、必要的概念”之间建立“清晰、准确、必要的关联”的过程。（增加连接） 38、人生的终极问题是“什么最重要”。 例如：要做新东方老师，最重要的是TOFEL考试成绩要高；怎么考好TOFEL，最重要的不是单词量，而是通过基础单词揣摩上下文逻辑的能力。 39、一切的半途而废/执行力不强，其最合理的科学解释，也是最朴素的解释是：重复与应用的次数不够，内化过程没有完成，大脑皮层沟回构建失败，应该建立的神经元关联不够强以致断掉，回到了原本没有关联的状态。 来源:https://book.douban.com/review/9169932/","link":"/2024/11/19/%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF-%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"AFNetworking","slug":"AFNetworking","link":"/tags/AFNetworking/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"hexo博客","slug":"hexo博客","link":"/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"iOS逆向","slug":"iOS逆向","link":"/tags/iOS%E9%80%86%E5%90%91/"},{"name":"NSData Byte","slug":"NSData-Byte","link":"/tags/NSData-Byte/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"crash","slug":"crash","link":"/tags/crash/"},{"name":"串","slug":"串","link":"/tags/%E4%B8%B2/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"物联网","slug":"物联网","link":"/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"物联网","slug":"物联网","link":"/categories/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"flutter 移动端","slug":"flutter-移动端","link":"/categories/flutter-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"swift","slug":"swift","link":"/categories/swift/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}