{"pages":[{"title":"正在整理中 。。。。。。","text":"","link":"/about/index.html"}],"posts":[{"title":"iOS逆向笔记","text":"逆向环境搭建iPhone越狱操作pp助手 爱思助手(一键越狱未成功) 刚开始使用unc0ver对几款iphone进行越狱安装后均显示不支持,所以改用checkra1n 先将官网放上https://checkra.in/ 刚开始用的官网下载的0.9.8.2刷机均中途报错 Exploit Failed (Error code: -31) 或 Timed out waiting for bootstrap upload(Likely caused by an incompatible tweak, to enable Safe Mode check the option on main screen) (Error code: -20) 后搜到这篇文章,看到有0.10.0版本的过段换最新的试试. https://mrmad.com.tw/checkra1n 最后贴上越狱成功下载地址 [v0.10.0 Beta](https://assets.checkra.in/test/checkra1n beta 0.10.0.dmg) mac远程登录iPhone通过ssh让mac远程登录iphone 1.手机端安装Cydia安装openssh工具 2.使用查看插件descrition中的描述 3.确保mac和iphone在同一局域网下,在mac的终端输入ssh 账户名@服务器主机地址 例如ssh root@10.1.1.168 (初始密码一般为alpine) 4.退出连接 exit 相关拓展: iOS下有2个常用账户:root/mobile root:最高权限账户,$HOME是/var/root mobile:普通权限账户,只能操作一些普通文件,不能操作系统级别的文件,$HOME是/var/mobile 修改登录密码 passwd 修改root密码 Passwd mobile 修改mobile用户密码 参考文章链接 Cycript通过cydia安装cycript可在iphone上调试运行中的app 常用指令 开启 cycript cycript -p 进程ID cycript -p 进程名称 取消输入: Ctrl + C 退出: Ctrl + D 清屏:Command + R 常用语法 UIApp 获取app对象 #内存地址 用内存地址获取对象 ObjectiveC.classes 已加载的所有OC类 *对象 查看对象的所有成员变量 view.recursiveDescription().toString() 递归打印view的所有子控件 choose(UITableViewCell) 筛选出某种类型的对象 mj工具类 ps命令手机安装adv-cmds插件 使用ps命令可以列出系统当前的进程 列出所有的进程 ps -A ps aux 搜索关键词 ps -A|grep 关键词 Reveal界面调试工具可以用其找到对应要操作视图类 Mach-O Class-dump对Mach-o文件进行静态分析,导出对应的头文件 导出指令 Class-dump -H Mach-O 文件路径 -o 头文件存放目录 -H表示要生成头文件 -o用于制定头文件的存放目录 头文件导出,可导出oc,swift过滤 http://stevenygard.com/projects/class-dump/ 参考 脱壳加壳是通过特殊算法,对可执行文件的编码进行改变(比如压缩/加密),以达到保护程序代码的目的. 脱壳就是将未加密的文件还原出来. 手机安装crackerXI插件,获取脱壳后文件,使用ifunbox将其导出. TWeak实战实战课参考此文章","link":"/2020/04/09/app%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/"},{"title":"Markdown常用语法","text":"第一章 块元素1.1标题标题有6个等级，用#号表示 1234567# 标题1## 标题2## 标题2### 标题2#### 标题4##### 标题5###### 标题6 1.2引用使用&gt;字符，表示引用 123&gt; This is a blockquote with two paragraphs. This is first paragraph.&gt; This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. This is a blockquote with two paragraphs. This is first paragraph.This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. 1.3列表12* red* blue red blue 121. red2. blue red blue 1.4任务列表用 [ ] 或者 [X] 未完成，完成）表示列表，通过点击复选框来更改状态（完成/未完成） 12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed a task list item list syntax required normal formatting, @mentions, #1234 refs incomplete completed 1.5代码块使用 ```&lt;语言&gt; 按回车键，将会对代码进行高亮 12345​```rubyrequire 'redcarpet'markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html​ 12345```rubyrequire 'redcarpet'markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html ###1.6数学 可以使用MathJax呈现LaTeX数学表达式 1234567$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\\\end{vmatrix}$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}$$ 1.7表格使用 | First Header | Second Header | 按回车键，将会创建2列的表格 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell 还可以使用 : 号，来设置文字对齐方式 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 ###1.8 脚注 1234使用 [^footnote] 创建脚注.You can create footnotes like this[^1].[^1]: Here is the *text* of the **footnote**.然后，可以把鼠标停留在脚注中，查看内容 You can create footnotes like this[^1].[^1]: Here is the text of the footnote. 1.10横线输入 *** 或者 — 后，按回车键 1.11目录输入 [toc] ，按回车键 [TOC] 第二章 Span元素2.1链接文字描述包含在 [] 内，链接地址包含在 () 内，() 要紧接着 [] 后面 12This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. This is an example inline link.This link has no title attribute. 2.1.1引用链接123[Bing][]And then define the link:[Bing]: http://bing.com/ BingAnd then define the link: 2.2图片123在链接格式前面添加 ! ，如下![在这里插入图片描述](http://pxebjkhug.bkt.clouddn.com/image-20190906161123468.png) 在链接格式前面添加 ! ，如下 ###2.3 强调 对应 HTML 的 标签 12*single asterisks*_single underscores_ single asterisks single underscores 如果像使用 * 号，在 * 号前使用 \\ 1\\*this text is surrounded by literal asterisks\\* *this text is surrounded by literal asterisks* 2.4加粗12**double asterisks**__double underscores__ double asterisksdouble underscores 2.5代码在文章中现实代码，用 ` 号表示 1Use the `printf()` function. Use the printf() function. 2.6删除线1~~Mistaken text.~~ Mistaken text. 2.7下划线1&lt;u&gt;Underline&lt;/u&gt; Underline ###2.8Emoji 表情 用两个 : 号包含单词，或者在 编辑 -&gt; 表情与符号 中选择 1:happy: :happy: 2.9高亮这个功能默认是关闭的，如果要打开这个功能（以 Mac 版本为例），选择 Typora -&gt; 偏好设置 -&gt; markdown 标签，勾选高亮复选框 1==highlight== ==highlight==","link":"/2019/09/10/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"},{"title":"ES6学习笔记","text":"ES6:ECMAScript是JavaScript的标准，JS是ES的实现，主流实现只有JS，所以很多时候JS就等同于ECMA正式名称：ES2015，是ECMA标准的第六版 变量:var存在的问题: 12345678910111、重复声明： var a=12; var a=5；2、不能限制修改： var GIT_HOST='github.com' if(GIT_HOST='git')3、块级作用域： ES5的var作用域——函数级 ES6的let作用域——块级 let:变量,防止重复定义const:常量,防止重复定义 小总结： 变量： var:重复声明，不能限制修改，函数级 let:不能重复声明，变量,块级 const:不能重复声明,常量，块级解构赋值:json = {a:12,b:5}; let (a,b)=json; arr = [1,2,3]; let [a,b,c]= arr; 12345671、两边结构必须一样 let {a,b}=[1,2]2、右边必须是个正常数据结构 let {a,b}={1,2}3、赋值与解构同时完成 let {a,b}; {a,b}={a:1,b:2} 箭头函数:function(){ ..... } ()=&gt;{}简写： 1、如果有且仅有一个参数，（）可不写 2、如果有且仅有一个语句并且是return，{}也可以不写 修正this …参数展开 收集剩余参数 1234function show(a,b,...c){ console(a,b,c);}show(1,2,3,4); ​ 展开 1234567891011数组展开let arr1 = [1,2,3];let arr2 = [4,5,6];let arr = [...arr1,...arr2]json展开let json = {a:12,b:5,c:99};let json2 = { ...json, d:100}; Array扩展:map 映射，一一对应（n=&gt;n）reduce n=&gt;1filter 过滤（n=&gt;?）forEach 遍历 1234567891011121314151617181920212223242526let arr = [68,53,32,98,65];let strArr =arr.map(function (item){ return item&gt;=60?'及格':'不及格';})//求平均数let pj = arr.reduce(function (tmp,item,index){ if(index == arr.length-1){ return (temp + item)/arr.length; }else{ return temp + item; }});//取出偶数let arr3 = arr.filter(item=&gt;{ if(item%2==1){ return false; }else{ return true; }})arr.forEach((item,index)=&gt;{ }) 模板字符串:1234let arr=[12,56,87,95,64]; arr.forEach((item,index) =&gt; { alert(`第${index}个：${item}`); }); JSON:stringify:JSON-&gt;字符串Parse:json字符串-&gt;JSON 12JSON.stringify({a:12,b:5}); =&gt; '{&quot;a&quot;:12,&quot;b&quot;:5}'JSON.parse('{&quot;a&quot;:12,&quot;b&quot;:5}'); babel编译 (向后适配)本地使用: 1、安装node 2、安装babel npm i @babel/core @babel/cli @babel/preset-env npm i @babel/polyfill 3、添加脚本 &quot;build&quot;:&quot;babel src -d dest&quot; //从src输出到dest 4、添加.babelrc配置文件 { &quot;presets&quot;:{ &quot;@babel/preset-env&quot; } } 5、执行编译 npm run build 异步操作:异步操作：同时进行多个操作，用户体验，es6之前代码混乱同步操作：一次只能进行一个操作，用户体验不好，代码清晰 异步的同步写法: 1234567891011121314151617181920212223242526Promise 1、封装异步操作 let p = new Promise(function(resolve,rejext){ $.ajex({ url:'', success(arr){ resolve(arr); }, error(res){ reject(res); } }); }); p.then(function(data){ console.log('成功了'); },function(res){ console.log('失败了'); }); 2、promise.all{[ //并行调用p1,p2 p1, p2, ... ]}.then 3、promise.race 竞速调用 123456789 async/await 普通函数——一直执行，直到结束 async函数——能够\"暂停\"async function show(){ ....; let data = await $.ajax(); //等待请求完成后继续执行 ....; } 面向对象语言发展： 机器语言-&gt;汇编语言-&gt;低级语言（面向过程）-&gt;高级语言（面向对象）-&gt;模块系统-&gt;框架-&gt;系统接口（API） 封装 ES5面向对象（未标准化） 没有统一的写法 ES6面向对象（语法糖） 统一的写法继承： 1、省事 2、便于扩展 ES6新加： class 类声明 constructor 构造函数 extends 继承关键字 super 父类/超类 123456789101112131415161718192021222324class Person{ constructor(name,age){ this.name = name; this.age = age; } showName(){ console.log(this.name); }}let p = new Person();p.showName();class Worker extends Person{ constructor(name,age,job){ super(name,age); this.job = job; } showJob(){ console.log(this.job); }} 模块系统1、定义 12export let a= 12;export let b = 5; 2、使用 1、导出（export） //变量 export let a=1; //函数 export function show(){ …… } //类 export class Person{ ……. } //默认成员 export default …. ​ 2、导入​ import * as model from xxx 引入所有成员​ import model from xxx 引入default成员​ import {a,b as name} from xxx​ //只引入，不使用​ import ‘xxx’​ //异步引入​ let p=import(xxxx)​ 3、webpack编译 (因暂时浏览器不支持模块化,所以是需要wp编译) ES6+幂操作 Array.includes() async/await reset/spread 异步迭代 正则表达式增强","link":"/2020/04/22/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"小程序flex布局","text":"尺寸单位rpx,规定屏幕宽为750rpx flex布局flex布局是小程序经常使用布局方式 开启方式: display:flex; (black-level形式存在) 或 display:inline-flex; (inline-level形式存在) 开启flex布局的元素叫flex container,其中直系子元素叫做flex items 属性flex-derection决定了main axis的方向 属性值: row | row-reverse | column | column-reverse justify-content决定了flex items在main axis上的对其方式 flex-start(默认值):与main start对齐 flex-end:与main-end对齐 center:居中对齐 space-between:items之间的距离相等,与main-start,main-end两端对齐 Space-evenly:items之间的距离相等,items与main-start,main-end之间的距离等于items之间的距离. Space-around:items之间的距离相等,与main-start,main-end之间的距离等于items之间的距离的一半 Align-items决定了在cross axis上的对其方式 stretcha(默认值):当flex-items在cross axis方向的size为auto时,会自动拉伸至填充flex container Flex-start:与cross start对齐 Flex-end:与cross end对齐 center: 居中对齐 Baseline:与基准下对齐 Flex-wrap决定了flex container是单行还是多行 nowrap(默认):单行 wrap:多行 Wrap-reverse:多行(对比wrap,cross start与cross end相反) flex-flow是flex-derection || flex-wrap的简写 比如flex-flow:column wrap等价于 Flex-derection:colunm Flex-warp:warp Align-content决定了多行flex items在cross axis上的对齐方式,用法与justify-content类似 stretch(默认值):与align-items的stretch类似 Flex-start:与cross start对齐 Flex-end:与cross end对齐 Center:居中对齐 Space-between:items之间的距离相等,与cross-start,cross-end两端对齐 Space-around:items之间的距离相等,与cross-start,cross-end之间的距离等于items之间的距离的一半 Space-evenly:items之间的距离相等,items与cross-start,cross-end之间的距离等于items之间的距离. order决定了flex items的排布顺序 可以设置任意整数(正负数/0),值越小就越排在前面 默认值为0 Align-self flex items可以通过align-self覆盖flex contaner设置的align-items auto(默认值):遵从flex container的align-items设置 Stretch/flex-start/flex-end/center/baseline Flex-grow决定了flex items如何扩展多余空间 可以设置任意非负数字(正数/0),默认值是0 当flex container在main axis方向上有剩余size时,flex-grow属性才有效 flex-shrink决定了flex items如何收缩 可以设置任意非负数字(正数/0),默认值是1 当flex itemx在main axis方向上超过了flex container的size,flex-shrink属性才有效 flex-basis用来设置flex items在main axis方向上的bese size auto(默认值): content:取决于内容本身的size 决定了flex items最终base size的因素,游戏那几从高到低 Max-width\\max-height\\min-width\\min-height Flex-basis Width\\height 内容本身的size flex是flex-grow flex-grow flex-shrink? || flex-basis的简写 默认值 0 1 auto none:0 0 auto","link":"/2020/04/22/%E5%B0%8F%E7%A8%8B%E5%BA%8Fflex%E5%B8%83%E5%B1%80/"},{"title":"微信小程序学习笔记","text":"一、小程序代码组成1.1 JSON配置123456789101112{ \"pages\":[ \"pages/index/index\", \"pages/logs/logs\" ], \"window\":{ \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" }} 注意点： 1.json的key必须包裹在一个双引号中； 2.json的值支持以下数据类型： ​ 数字：包含浮点数和整数 ​ 字符串：需要包裹在双引号中 ​ Bool值，true或者false ​ 数组：需要包裹在方括号中[] ​ 对象：需要包裹在大括号中{} ​ Null 3.json文件无法使用注释 1.2 WXML模板 1.数据绑定 12&lt;!--pages/wxml/index.wxml--&gt;&lt;text&gt;当前时间：{{time}}&lt;/text&gt; ​ 2.属性值的绑定(属性值必须被包裹在双引号中) 1&lt;text data-test=\"{{test}}\"&gt; hello world&lt;/text&gt; 语法内可进行简单的逻辑运算 123456三元运算&lt;!-- 根据 a 的值是否等于 10 在页面输出不同的内容 --&gt;&lt;text&gt;{{ a === 10? \"变量 a 等于10\": \"变量 a 不等于10\"}}&lt;/text&gt;算数运算&lt;view&gt; {{a + b}} + {{c}} + d &lt;/view&gt; 4.条件逻辑 12345&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;&lt;view wx:if=&quot;{{length &gt; 5}}&quot;&gt; 1 &lt;/view&gt;&lt;view wx:elif=&quot;{{length &gt; 2}}&quot;&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 5.列表渲染 12345678&lt;view wx:for=\"{{array}}\"&gt; {{index}}: {{item.message}}&lt;/view&gt;&lt;!-- 使用 wx:for-item 指定数组当前元素的变量名，使用 wx:for-index 指定数组当前下标的变量名：--&gt;&lt;view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\"&gt; {{idx}}: {{itemName.message}}&lt;/view&gt; 6.wx:key的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 123456&lt;switch wx:for=&quot;{{objectArray}}&quot; wx:key=&quot;unique&quot; &gt; {{item.id}} &lt;/switch&gt;&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;&lt;switch wx:for=&quot;{{numberArray}}&quot; wx:key=&quot;*this&quot; &gt; {{item}} &lt;/switch&gt;&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add Number to the front &lt;/button&gt; 7.模板 12345678910111213141516&lt;!--item: { index: 0, msg: 'this is a template', time: '2016-06-18'}--&gt;&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt; &lt;text&gt; Time: {{time}} &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt; 8.引用 WXML 提供两种文件引用方式import和include。 import 可以在该文件中使用目标文件定义的 template，只会 import 目标文件中定义的 template，而不会 import 目标文件中 import 的 template，简言之就是 import 不具有递归的特性 include 可以将目标文件中除了 外的整个代码引入，相当于是拷贝到 include 位置 1.3 WXSS 样式 1.在WXSS中，引入了rpx（responsive pixel）尺寸单位,标准为750*1334rpx,标准和iphone6一样 2.引用 引用另一个样式文件：@import './test_0.wxss' 3.内联样式 1&lt;view style=&quot;color: red; font-size: 48rpx&quot;&gt;&lt;/view&gt; 4选择器 类型 选择器 样例 样例描述 类选择器 .class .intro 选择所有拥有 class=”intro” 的组件 id选择器 #id #firstname 选择拥有 id=”firstname” 的组件 元素选择器 element view checkbox 选择所有文档的 view 组件和所有的 checkbox 组 伪元素选择器 ::after view::after 在 view 组件后边插入内容 伪元素选择器 ::before view::before 在 view 组件前边插入内容 1.4JavaScript 脚本生命周期函数 参数属性 类型 描述 onLoad Function 生命周期函数–监听页面加载，触发时机早于onShow和onReady onReady Function 生命周期函数–监听页面初次渲染完成 onShow Function 生命周期函数–监听页面显示，触发事件早于onReady onHide Function 生命周期函数–监听页面隐藏 onUnload Function 生命周期函数–监听页面卸载 onPullDownRefresh Function 页面相关事件处理函数–监听用户下拉动作 onReachBottom Function 页面上拉触底事件的处理函数 onShareAppMessage Function 用户点击右上角转发 二、小程序界面2.1组件一个小程序页面可以分解成多个部分组成，组件就是小程序页面的基本组成单元。为了让开发者可以快速进行开发，小程序的宿主环境提供了一系列基础组件。 组件共有属性 属性名 类型 描述 其他说明 id String 组件的唯一标示 保持整个页面唯一 class String 组件的样式类 在对应的WXSS中定义的样式类 style String 组件的内联样式 可以通过数据绑定进行动态设置的内联样式 hidden Boolean 组件是否显示 所有组件默认显示 data-* Any 自定义属性 组件上触发的事件时，会发送给事件处理函数 bind / catch EventHandler 事件 绑定、捕获事件 微信官方组件https://developers.weixin.qq.com/miniprogram/dev/component/ 三方组件：https://youzan.github.io/vant-weapp/#/intro 2.2常见事件 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发 2.3page生命周期函数 三、API宿主环境提供了丰富的API，可以很方便调起微信提供的能力. 3.1路由跳转​ wx.switchTab(Object object) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 ​ wx.navigateTo(Object object)保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 3.2网络请求12345678910111213wx.request({ url: 'test.php', //仅为示例，并非真实的接口地址 data: { x: '', y: '' }, header: { 'content-type': 'application/json' // 默认值 }, success (res) { console.log(res.data) }}) 属性 类型 默认值 必填 说明 url string 是 开发者服务器接口地址 data string/object/ArrayBuffer 否 请求的参数 header Object 否 设置请求的 header，header 中不能设置 Referer。 content-type 默认为 application/json timeout number 否 超时时间，单位为毫秒 method string GET 否 HTTP 请求方法 dataType string json 否 返回的数据格式 responseType string text 否 响应的数据类型 enableCache boolean false 否 开启 cache success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 常用object.method 的合法值 值 说明 GET HTTP 请求 GET HEAD HTTP 请求 HEAD POST HTTP 请求 POST PUT HTTP 请求 PUT 3.3 数据缓存wx.setStorage(Object object) 将数据存储在本地缓存中指定的 key 中，所有数据存储上限为 10MB。 1234567891011wx.setStorage({ key:&quot;key&quot;, data:&quot;value&quot;})wx.getStorage({ key: 'key', success (res) { console.log(res.data) }}) wx.getStorage(Object object) 从本地缓存中异步获取指定 key 的内容 3.4 其他 更多api可以查看官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/ 四、云开发","link":"/2020/05/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"栈","text":"","link":"/2019/09/11/%E6%A0%88/"},{"title":"树","text":"","link":"/2019/09/16/%E6%A0%91/"},{"title":"线性表","text":"","link":"/2019/09/11/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"title":"队列","text":"","link":"/2019/09/11/%E9%98%9F%E5%88%97/"},{"title":"hexo博客搭建教程","text":"###简介 Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。 ###安装 因自己使用的mac电脑，这里以mac安装发布为例，windows大体差不多。 1.1电脑本地创建一个文件夹，例如我这里的blog。 1.2 打开电脑终端执行以下命令： 12$npm install -g hexo-cli$ hexo init 如果npm指令出现此报错zsh: command not found: node,需安装nodejs环境,下载链接 1.3 安装完成后，指定文件夹的目录如下 ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中_config.yml文件用于存放网站的配置信息，你可以在此配置大部分的参数；scaffolds是存放模板的文件夹，当新建文章时，Hexo会根据scaffold来建立文件；source是资源文件夹，用于存放用户资源，themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。 1.4生成静态博客，在终端执行命令： 1hexo s Hexo将source文件夹中的Markdown 和 HTML 文件会被解析并放到public文件夹中，public文件夹用于存放静态博客文件，相当于网站根目录。至此博客雏形基本完成，在浏览器中访问http://localhost:4000/，如图所示： 2.1主题更换 前往主题页，选择喜欢的主题： 2.2 挑选喜欢的主题后，将主题clone到blog的themes文件夹下 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 2.3 修改_config.yml中对应的主题字段为你选择的主题名 到此主题更换成功，可以本地hexo s本地看看是否替换成功。 3.1发布到github 可以参看这篇文章：怎么把Hexo的博客托管到Git上 4.常用hexo命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 指令缩写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令 12hexo s -g #生成并本地预览hexo d -g #生成并上传 5.Hexo博客多端同步解决办法","link":"/2019/09/06/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"title":"串","text":"","link":"/2019/09/11/%E4%B8%B2/"},{"title":"AFNetworking笔记","text":"AFNetworking 一 代码结构 主要有5大功能模块: 网络通信模块（最核心）（AFURLSessionManager、AFHTTPSessionManager） 网络状态监听模块（Reachability） 网络通信安全策略模块（Security） 网络通信信息序列化/反序列化模块（Serialization） 对于iOS UIkit库的拓展（UIKit） 二 AFHTTPSessionManager发起网络请求首先来看初始化AFHTTPSessionManager对象的过程，其中需要注意的是[AFHTTPSessionManager manager]方法并不是单例，最终调用的是下面初始化方法,工厂设计模式。 在AFHTTPSessionManager初始化中主要做了 1、调用父类初始化方法; 2、给URL加’’; 3、给requestSerializer、responseSerializer设置默认值 给url加’/‘的目的应该是1、防重发 2、方便在url后面直接拼接参数。 12345678910111213141516- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration{ self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) { url = [url URLByAppendingPathComponent:@&quot;&quot;]; } self.baseURL = url; self.requestSerializer = [AFHTTPRequestSerializer serializer]; self.responseSerializer = [AFJSONResponseSerializer serializer]; return self;} 下面来看AFURLSessionManager初始化方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super init]; if (!self) { return nil; } if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; self.responseSerializer = [AFJSONResponseSerializer serializer]; self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self;} 主要步骤有： sessionConfiguration 属性持有 configuration ，若传入configuration为空，设置默认defaultSessionConfiguration。包含缓存策略，ID，超时时间 … 初始化代理方法执行的队列operationQueue，并设置 maxConcurrentOperationCount 值为1。即串行执行 responseSerializer 解析方式， securityPolicy 使用defaultPolicy初始化，https证书校验对象，用来校验服务端安全信任链接 reachabilityManager 网络状态监听。 mutableTaskDelegatesKeyedByTaskIdentifier 类型是NSMutableDictionary，key是NSURLSessionTask的唯一NSUInteger类型标识，value是对应的AFURLSessionManagerTaskDelgate对象 lock ，NSLock类型锁创建，为了保证线程安全 session对象创建，3.0版本是直接创建。4.0版本是懒加载形式创建，并使用@synchronized互斥锁保证只创建一次 session 调用getTasksWithCompletionHandler方法获取 之前的task，创建AFURLSessionManagerTaskDelegate。绑定task，并加入mutableTaskDelegatesKeyedByTaskIdentifier字典中 manager的研究先到这里，里面各种配置的具体实现，暂时先不往深处介绍了，下面来看下request的实现方法 request方法解析 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(nullable id)parameters headers:(nullable NSDictionary &lt;NSString *, NSString *&gt; *)headers uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure{ NSError *serializationError = nil; //URLWithString:(NSString *)URLString relativeToURL: 拼接字符串 //absoluteString完整的url字符串 NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; for (NSString *headerField in headers.keyEnumerator) { [request setValue:headers[headerField] forHTTPHeaderField:headerField]; } if (serializationError) { if (failure) { dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); } return nil; } __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; return dataTask;} 1、这个过程主要是使用requestSerializer 调用requestWithMethod 或者 multipartFormRequestWithMethod 获取 NSMutableURLRequest 类型的 request 对象。 使用指定的HTTP method和URLString来构建一个NSMutableURLRequest对象实例，如果method是GET、HEAD、DELETE，那parameter将会被用来构建一个基于url编码的查询字符串（query url），并且这个字符串会直接加到request的url后面。对于其他的Method，比如POST/PUT，它们会根据parameterEncoding属性进行编码，而后加到request的http body中。 1234- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters error:(NSError *__autoreleasing *)error 在上面这个方法里设置了request的 请求方法，url，遍历mutableObservedChangedKeyPaths中设置的属性并给Request赋值。 调用[mutableRequest setValue:value forHTTPHeaderField:field]方法设置请求头相关信息。 非HTTPMethodsEncodingParametersInURI的请求先判断request的Content-Type是否设置了，如果没有，就默认设置为application/x-www-form-urlencoded。 在方法 multipartFormRequestWithMethod 中比 requestWithMethod 多了个参数为formData 的 block 对象参数。在方法体里面对formData 进行拼接。然后通过block传出去。此处设计与Masonry框架中block使用方式相同，可以放一块研究一下。 2、调用 dataTaskWithRequest 方法，使用上面的 request 生成 task 对象。 12NSURLSessionDataTask *dataTask = [self.session dataTaskWithRequest:request];[self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; addDelegateForDataTask 方法将初始化一个 AFURLSessionManagerTaskDelegate 对象，delegate 弱引用又持有了 manager, 打破闭环。在delegate中有 进度，回调，存储数据的mutableDate等属性。 在addDelegateForDataTask 中调用 setDelegate：forTask 将task 和 delegate 绑定到一起。 在setDelegate:forTask 方法中 1、将delegate存入字典，以taskid作为key，说明每个task都有各自的代理； 2、设置两个NSProgress的变量 - uploadProgress和downloadProgress，给session task添加了两个KVO事件 设置这两个NSProgress对应的cancel、pause和resume这三个状态，正好对应session task的cancel、suspend和resume三个状态 当NSURLSessionTask调用resume函数时，会postNotificationName:AFNSURLSessionTaskDidResumeNotification，从而执行taskDidResume:方法 在 taskDidResume: 方法中会判断task是否是当前manager管理的，是的话会发送通知AFNetworkingTaskDidResumeNotification 3、task调用resume 执行 resume 方法被 使用 method_exchangeImplementations交换为 af_resume方法。内部发送了AFNSURLSessionTaskDidResumeNotification 通知。 参考文章: https://juejin.cn/user/3729141714925687/posts","link":"/2020/05/14/AFNetworking%E7%AC%94%E8%AE%B0/"},{"title":"React学习笔记","text":"DAY1React生态圈jsx:拓展了js自身的语法,是react的基础 Flux:react的数据流组件 Redux:比flux更加简单、易用 React-Native:用react编写原生移动应用 React-server:服务端渲染react组件 jsx jsx是一门独立的语言,希望能改进js的很多问题,但是es6出现后,包含了jsx的大部分特性,所以很少独立使用 babel可以编译jsx react是基于jsx语法 提供模板式创建元素的方法 123456//普通元素创建let oDiv = document.createElement('div');odiv.title = 'aaa';oDiv.innerHTML = 'BBB';//jsx方式let oDiv = &lt;div title=\"aaa\"&gt;BBB&lt;/div&gt; 注意:jsx并不会真正创建dom元素,jsx只是解析模板语法,创建虚拟DOM节点,需经由ReactDOM渲染才会成为真正的DOM元素. 关于虚拟DOM 直接操作dom元素非常缓慢,所以很多框架(vue,react)都具备虚拟dom特性,我们直接操作的是虚拟dom,而非真正节点,react会在何时的实际批量更新dom节点(一般是主进程空闲时),从而提高性能. 能否单独使用jsx? 不能,react强依赖jsx用于解析jsx语法,但是jsx也强依赖react用于解析模板语法 第一个react程序 12345678910111213//引入js文件 &lt;script src=&quot;js/browser.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/react-dom.js&quot;&gt;&lt;/script&gt; //容器 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; //react渲染,经过babel编译才能执行 &lt;script type=&quot;text/babel&quot;&gt; let root = document.getElementById('root'); ReactDOM.render(&lt;div&gt;aaa&lt;/div&gt;,root); &lt;/script&gt; 特殊属性 react中类”html代码”,其实不是真正的html,而是jsx语法,绝大部分标签与html一样,但是有两个属性需要修改 class:className for:htmlFor 单标签 react中单标签必须闭合(html标签和自定义组件都是) ; 错误 ; 正确 react组件组件 123456789101112131415161718 //组件定义 class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ let a = 12; let name = 'qpc'; let age = 18; return &lt;div&gt; &lt;span style={{color:'red'}}&gt;你好&lt;/span&gt; 姓名:{name} 年龄:{age}&lt;/div&gt;; } }//组件渲染 let root = document.getElementById('root'); ReactDOM.render(&lt;Cmp1 txt=&quot;qpc&quot;&gt;&lt;/Cmp1&gt;,root); 注意: 组件必须继承React.Component 组件必须有constructor()且super父级,否则状态等功能无法使用 组件必须有render()方法 组件类名必须首字母大写 组件使用时,单双标签都可以 组件中的html必须规范(双标签闭合,单标签结尾加/) 模板输出 输出变量、属性、方法、任何东西都可以 123456789101112131415161718192021222324252627class Cmp1 extends React.Component{ constructor(...args){ super(...args); this.age = 18; } fn(){ return 55; } render(){ let name = 'qpc'; let age = 18; const a = 66; return &lt;div&gt; &lt;span style={{color:'red'}}&gt;你好&lt;/span&gt; //输出变量 姓名:{name} //输出属性 年龄:{this.age} {this.fn()}; //输出到属性 &lt;div title={a}&gt;div2&lt;/div&gt; &lt;/div&gt;; } } 组件传参 用props接受参数 1234567891011class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ return &lt;div&gt; {this.props.a},{typeof(this.props.a)} &lt;/div&gt; } } 组件输出 123456789101112131415161718192021222324 class Cmp1 extends React.Component{ constructor(...args){ super(...args); } render(){ let spana = &lt;span&gt;aaa&lt;/span&gt; return &lt;div&gt; {spana} &lt;/div&gt; } }//输出一组元素 render(){ let arr = [ &lt;span key={0}&gt;aaa&lt;/span&gt;, &lt;span key={1}&gt;bbb&lt;/span&gt;, &lt;span key={2}&gt;ccc&lt;/span&gt; ]; return &lt;div&gt; {arr} &lt;/div&gt; } 关于key key非常重要，它关联虚拟dom和真实dom，从而在虚拟dom修改时对实际dom元素做最小化额修改以此提高性能，普通元素其实也有key，由react自己生成 注意：尽量不要用index作为key,因为index是会变化的（比如删掉一个元素，后续元素的index会变化） key的选择标准： 唯一：否则reactdom无法重用 不变：否则dom元素混乱 组件循环 12345678render(){ let arr = [1，2，3]; return &lt;div&gt; {arr.map((item,index) =&gt;( &lt;span key={index}&gt;{item}&lt;/span&gt; ))} &lt;/div&gt;} 组件嵌套 1234567891011121314151617181920212223242526272829303132333435363738class item extends React.Component{ constructor(...args){ super(...args); } render(){ return ( &lt;li&gt; {this.props.data} &lt;/li&gt; ) } }class list extends React.Component{ constructor(...args){ super(...args); } render(){ let arr = [1,2,3]; return ( &lt;ul&gt; {arr.map((n,index)=&gt;&lt;item key={index} data={n}&gt;&lt;/item&gt;)} &lt;/ul&gt; ) } }//输出一组元素 render(){ let arr = [ &lt;span key={0}&gt;aaa&lt;/span&gt;, &lt;span key={1}&gt;bbb&lt;/span&gt;, &lt;span key={2}&gt;ccc&lt;/span&gt; ]; return &lt;div&gt; {arr} &lt;/div&gt; } 组件状态 状态 属性是只读的，状态是可变的 状态的改变，组件会重新渲染 1234567891011121314151617181920class Cmp1 extends React.Component{ constructor(...args){ super(...args); //初始化状态 this.state={a:0}; } add(){ this.setState({ a:this.state.a+1 }); } render(){ return &lt;div&gt; &lt;input type=\"button\" value=\"加1\" onClick={thi.add.bind(this)}&gt;&lt;/input&gt; {this.state.a} &lt;/div&gt; } } 注意： 状态的初始化只能在constructor中完成 必须通过setState修改状态，否则也不能重新渲染——setState调用了render props变化引起重新渲染 强制渲染(forceUpdate) 组件生命周期 componentDidMount组件已经挂载 shouldComponentUpdate:即将开始更新组件，可以阻值更新发生 componentDidUpdate组件已更新 组件引用 ref：需用引用的组件 refs:父级中引用所有ref组件 实例：求和 12345678910111213141516171819202122class Cmp1 extends React.Component{ constructor(...args){ super(...args); //初始化状态 this.state={sum:0}; } fn(){ this.setState({ sum:parseInt(this.refs.num1.value)+parseInt(this.refs.num2.value) }); } render(){ return &lt;div&gt; &lt;input type=\"text\" ref=\"num1\"/&gt; &lt;input type=\"text\" ref=\"num2\"/&gt; &lt;input type=\"button\" value=\"求和\" onClick={thi.fn.bind(this)}/&gt; {this.state.sum} &lt;/div&gt; } } 和vue有所不同，react中的ref不能重复，如果重复，后面的会覆盖掉前面的 组件通信 redux","link":"/2020/05/13/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"iOS线上crash日志分析","text":"因为线上统计用的百度sdk,现在记录下针对百度错误日志的手动分析方法,其官网文档有自动和手动分析两种方法. 这里记录一下自己手动定位crash报错方法的流程: 百度移动统计iOS SDK获取的crash日志不是完整的系统生成日志，其内容主要包括异常类型、原因、Backtrace调用等. SDK V3.5及以上的SDK，日志格式会在头部新增相关信息，如下: 1234UUID: 538572BD-D973-3D55-A475-4579BA0BECBFNAME: BaiduMobStatSampleARCH: x86_64ADDR: 0x100000000 bug分析命令：**xcrun atos –arch arm64 -o +包路径 -l 基地址 + 偏移地址** 1、获取包路径 （1）XCode-&gt;Window-&gt;Organizer （2）找到对应的安装包并双击点击show in Finder （3）双击.xcarchive文件显示包内容 （4）双击.app.dsYM文件显示报内容 （5）按照如下路径找到APP名字的文件 （6）打开终端输入(xcrun atos -arch arm64 -o )然后（将appname文件拖到此处，如下图） （7）输入（-l）+ (崩溃日志中的ADDR如下图) + （APPname后面对应的一串字符如下图的蓝圈内的地址）输入完成之后回车就可以了 8、最终结果如下，会解析出类名，和报错的行数","link":"/2020/07/27/iOS%E7%BA%BF%E4%B8%8A%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%88%86%E6%9E%90/"},{"title":"iOS音视频开发","text":"","link":"/2020/05/28/iOS%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"},{"title":"iOS知识点整理","text":"### 1.1.iOS 静态库，动态库与 Framework 1.2从xib中自定义view的最佳姿势","link":"/2020/09/18/iOS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"},{"title":"protobuf iOS使用","text":"为什么使用protobuf 在不同平台通信的时候，首先需要将对象进行序列化。iOS平台上我们常用NSKeyedArchiver进行归档，当然也可以将数据处理为JSON或者XML格式。NSKeyedArchiver只能在iOS/Mac平台使用，因此它归档的二进制数据不适合于在不同平台之间使用。JSON和XML虽然由于容易维护，易读而应用比较广泛，但是对数据的利用效率都不是高。这时候该使用Protobuf了,因为Protobuf的优势是效率高，同样的一份数据使用protobuf存储的时候更小，更加方便 Protobuf是什么 Protobuf 即 google protocol buffer 是一种数据封装格式协议,是google推出的一种语言无关、平台无关、扩展性好的用于通信协议、数据存储的结构化数据串行化方法。 使用Protobuf大致分三步: 1.集成protoc工具 2.根据自己的需求创建proto文件并转换 3.向自己的项目集成protocbuf 一、集成protoc环境1.下载protoc项目2.生成protoc编译器cd到下载目录，终端依次执行以下命令 12345./autogen.sh./configuremakesudo make installobjectivec/DevTools/full_mac_build.sh 成功后在src文件夹下会有个protoc文件 二、使用protoc转换文件1.根据需求新建后缀为proto的文件,例: XXXX.proto 2.转换1protoc --proto_path=路径1 --objc_out=路径2 XXXX.proto 路径1 : 创建的proto文件所在目录 路径2 : 转换后的文件输出路径 XXXX.proto : 创建的proto文件名称 例: 在桌面创建放proto文件的文件夹 “MySrc”, 在 “MySrc” 里创建proto文件auth.proto, 在桌面创建放转换后的文件的文件夹 “MyGen”, 则在终端 先cd 到桌面 1protoc --proto_path=MySrc --objc_out=MyGen MySrc/XXX.proto 执行命令后会发现在 “MyGen” 文件夹中出现 XXX.pbobjc.h / XXX.pbobjc.m, 这两个就是我们项目中需要的文件。 三.向项目集成protobuf将生成的Objective-C文件（上面例子的XXX.pbobjc.h和XXX.pbobjc.m）放到项目中，如果项目使用了ARC,要将.m（例子的XXX.pbobjc.m）的Complier Flags设为-fno-objc-arc。（protobuf基于性能原因没有使用ARC） 加入protobuf库，有两种方式 第一种是使用CocoaPods集成 使用CocoaPods集成，有一个现成的pod可以使用–Protobuf,可以pod search Protobuf搜索查看详情，pod内容为 1pod 'Protobuf' 第二种是把相关文件拖入项目中。 拖入相关文件到项目中，将objective-c文件夹下的所有的.h文件和.m文件（除了GPBProtocolBuffers.m）(GPB开头的那些文件)以及整个google文件夹add到项目中，如果项目中使用了ARC需要将以上所有.m文件的的Complier Flags设为-fno-objc-arc。缺点是操作麻烦点，如果用了ARC的话还要手动添加-fno-objc-arc（使用CocoaPods集成会自动添加）,记得添加User Header Search Paths为$(PROJECT_DIR)/项目名/后接文件地址 不然头文件会报错 完成，可以使用这个类进行操作了。","link":"/2020/08/14/protobuf-iOS%E4%BD%BF%E7%94%A8/"},{"title":"VUE基础","text":"","link":"/2020/10/10/VUE%E5%9F%BA%E7%A1%80/"},{"title":"读&lt;&lt;图解物联网&gt;&gt;","text":"感觉物联网现在越来越热门,智能家居/工业物联网应用越来越多,于是想全面的连接物联网基本知识结构,所以看了该书.感觉不错,本书从硬件到软件到物联云,系统了讲解了开发物联网应用需要的知识. 全书看下来,感觉当前还是处于物联网初期,感觉物联网应用的比较多的还是工业,智能家居也有不少的用户开始接受了,但是比较零散,很多没有形成系统,很多设备只是简单了添加联网模块,未给硬件添加智能化和自动化,不过自动驾驶应该是一项技术突破,设计到n多传感器和自动化驾驶.","link":"/2020/07/01/%E8%AF%BB-%E5%9B%BE%E8%A7%A3%E7%89%A9%E8%81%94%E7%BD%91/"},{"title":"iOS蓝牙知识整理","text":"最近又要捣鼓一下蓝牙文件传输,想把之前总结漏掉的在重新整理下,搜索和连接等基本操作之前的这篇好了,这次主要做一下补充 Bluetooth蓝牙篇（BLE） 推荐参考文章: iOS蓝牙知识快速入门","link":"/2021/05/26/iOS%E8%93%9D%E7%89%99%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"title":"iOS性能优化","text":"一、静态分析Xcode 自带的静态分析工具 Analyze，通过静态语法分析能够找出在代码层面就能发现的内存泄露问题，还可以通过上下文分析出是否存在变量无用等问题。但是，Analyze 的功能还是有限，还是无法帮助我们在编写代码的阶段发现更多的问题。所以，这才诞生出了功能更全、定制化高、效率高的第三方静态检查工具。比如OCLint、Infer等 Analyze分析参考文章： Analyze静态分析 Infer静态分析工具使用： https://www.cnblogs.com/ZachRobin/p/11280499.html 二、包大小瘦身2.1删除无用资源图片资源优化 1.删除无用图片 使用插件：https://github.com/tinymind/LSUnusedResources 2.图片资源压缩 部分图片采用webp格式 图片压缩工具：https://tinypng.com/ 2.2代码瘦身 感谢踩坑小分队提供的瘦身py脚本系列工具集：https://www.jianshu.com/p/bde52cc0b5d5 如果工程量不是很大的话，可以使用 AppCode 来做分析，用 AppCode 做分析的方法很简单，直接在 AppCode 里选择 Code-&gt;Inspect Code 就可以进行静态分析。 **** 无用类查找 python FindClassUnRefs.py -p /Users/pengchengqin/Library/Developer/Xcode/DerivedData/-fdgdsseeslsaryblrnxopmyfmdwl/Build/Products/Debug-iphoneos/.app -b Pod,AF,SD,BM,MJ,JX,FM,IQ 三、线下性能分析工具Instruments 四、app崩溃日志信息监控代码线上埋点分析：bugly (https://bugly.qq.com/) 五、卡顿原因及优化在屏幕成像的过程中，CPU和GPU起着至关重要的作用 CPU（Central Processing Unit，中央处理器） 对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics） GPU（Graphics Processing Unit，图形处理器） 纹理的渲染 卡顿原因 卡顿优化（CPU方面） 尽量用轻量级的对象，用不到时间处理的地方可以，可以使用CALayer取代UIView 不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性 Autolayout会比直接设置frame消耗更多的CPU资源 图片的size最好刚好跟UIImageView的size保持一致 控制一下线程的最大并发数量 尽量把耗时的操作放到子线程 文本处理（尺寸计算、绘制） 图片处理（解码、绘制） 卡顿优化（GPU方面） 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸 尽量减少视图数量和层次 减少透明的视图（alpha&lt;1），不透明的就设置opaque为YES 尽量避免出现离屏渲染 离屏渲染 在OpenGL中，GPU有2种渲染方式 On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作 Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作 离屏渲染消耗性能的原因： 需要创建新的缓冲区 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕 哪些操作会触发离屏渲染？ 光栅化，layer.shouldRasterize = YES 遮罩，layer.mask 圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0 可以考虑通过CoreGraphics绘制裁剪圆角，或者美工提供圆角图片 阴影，layer.shadowXXX 如果设置了layer.shadowPath就不会产生离屏渲染 六、耗电优化耗电主要来源： 少用定时器 优化I/O操作 尽量不要频繁写入小数据，最好批量一次性写入 读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问 数据量比较大的，建议使用数据库（比如SQLite、CoreData） 网络优化 减少、压缩网络数据 ，能缓存数据尽量缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载 定位优化 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion: 硬件检测优化 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件 参考文章：iOS耗电量优化实践（https://www.jianshu.com/p/bd2c1ce5c02a）","link":"/2021/01/22/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"title":"app启动优化","text":"启动分类: 1.冷启动: 从用户点击App图标开始到appDelegate didFinishLaunching方法执行完成为止。这是一次完整的启动过程。 2.热启动:App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 启动主要步骤: T1：main()函数之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载&amp;链接等工作，最后执行至App的main()函数。 T2：main()函数之后，即从main()开始，到appDelegate的didFinishLaunchingWithOptions方法执行完毕。 T3:当didFinishLaunchingWithOptions执行完成时，用户还没有看到App的主界面，也不能开始使用App。这个阶段会一般会首页渲染和数据请求后，用户才能真正看到主页面。 T1阶段及优化 阶段 工作 加载动态库 Dyld从主执行文件的header获取到需要加载的所依赖动态库列表，然后它需要找到每个 dylib，而应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以所需要加载的是动态库列表一个递归依赖的集合 Rebase和Bind - Rebase在Image内部调整指针的指向。在过去，会把动态库加载到指定地址，所有指针和数据对于代码都是对的，而现在地址空间布局是随机化，所以需要在原来的地址根据随机的偏移量做一下修正 - Bind是把指针正确地指向Image外部的内容。这些指向外部的指针被符号(symbol)名称绑定，dyld需要去符号表里查找，找到symbol对应的实现 Objc setup - 注册Objc类 (class registration) - 把category的定义插入方法列表 (category registration) - 保证每一个selector唯一 (selector uniquing) Initializers - Objc的+load()函数 - C的构造函数属性函数 - 非基本类型的C静态全局变量的创建(通常是类或结构体) 优化： 1.减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司建议最多使用 6 个非系统动态库。 2.减少无用类和方法，代码瘦身 3.+load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。 4.控制 C++ 全局变量的数量 T2阶段及优化 这个阶段在我看来主要是didFinishLaunchingWithOptions里面代码的执行： 优化： 分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段 T3阶段及优化 主界面的构建 优化： 1.优化耗时操作：这个就要分析代码中是否存在图片I/O、图片解码、archive文档等隐含着一些耗时操作； 2.优化串行操作。 启动速度监控工具 1.查看T1阶段时间 通过添加环境变量可以打印出APP的T1启动时间分析（Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Arguments-&gt;Environment Variables-）DYLD_PRINT_STATISTICS设置为1； 如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1。 2.查看T1之后耗时 方案一:定时抓取主线程方法的调用堆栈，计算一段时间里的方法耗时。（Xcode中的Time Profiler就是使用的这种的方法） 方案二:对objc_msgSend方法进行hook，来得到所有方法的耗时。 方案二工具实现https://github.com/QiShare/Qi_ObjcMsgHook 参考文章: https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html https://time.geekbang.org/column/article/85331","link":"/2021/03/24/app%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"hexo博客","slug":"hexo博客","link":"/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"串","slug":"串","link":"/tags/%E4%B8%B2/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"AFNetworking","slug":"AFNetworking","link":"/tags/AFNetworking/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"iOS逆向","slug":"iOS逆向","link":"/tags/iOS%E9%80%86%E5%90%91/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"crash","slug":"crash","link":"/tags/crash/"},{"name":"物联网","slug":"物联网","link":"/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"物联网","slug":"物联网","link":"/categories/%E7%89%A9%E8%81%94%E7%BD%91/"}]}